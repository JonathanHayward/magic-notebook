#!FULL_TCL_PATH

#
# Snippets/Sidebar in a Can/The Magic Notebook is (c) 2001-3 by Jonathan
# Hayward, released under the Artistic License, and comes with no warranty.
# Please visit my homepage at http://JonathansCorner.com to see what else I've
# created--not just software.
#
# I'd like to thank the following people for helping me debug or otherwise
# get this program in working order:
#	Waidelich Burkhard
#	Stuart Cassoff, who furnished the configuration file code
#	Bruce Hartweg
#	Jeff Hobbs
#	Paul Johnson
#	Cameron Laird
#	Mick O'Donnell
#	George Schlitz
#	Kurt Wimmer
#
#	Mike Doyle, for introducing me to Tcl and giving me several good Tcl
#	books to start hacking with.
#
#	and various other people from comp.lang.Tcl whose names I didn't get down.
#
# Thanks also to Kapocs Web Design, kapocs.hypermart.net, and HSD2 Tech
# Support, www.harrison.k12.co.us, for providing attractive backgrounds for
# free download--including the one I used.
#

set configFilename "CONFIG_FILENAME"

#
# Utility routines.  Many of these have been provided by other programmers.
#

proc CGIKeys {} {
	set scratch [CGIList]
	set toggle 1
	foreach entry $scratch {
		if {$toggle} {
			lappend result $entry
			set toggle 0
		} else {
			set toggle 1
		}
	}
	return $result
}

#Cosmetically adapted from Brent B. Welch, _Practical Programming in Tcl and
#Tk_
proc CGIList {} {
	set query [CGIQuery]
	regsub -all {\+} $query { } query
	set result {}
	foreach {x} [split $query &=] {
		lappend result [URLDecode $x]
	}
	return $result
}

#Cosmetically adapted from Brent B. Welch, _Practical Programming in Tcl and
#Tk_
#
# Modified by Jonathan Hayward 8/24/02 so that later values overwrite earlier
# ones.
#
proc CGIParse {} {
	global cgi cgilist
	catch {unset cgi cgilist}
	set query [CGIQuery]
	regsub -all {\+} $query { } query
	foreach {name value} [split $query &=] {
		set name [URLDecode $name]
#		if {[info exists cgilist($name)] &&
#				($cgilist($name) == 1)} {
#			set cgi($name) [list $cgi($name) \
#				[URLDecode $value]]
#		} elseif {[info exists cgi($name)]} {
#			lappend cgi($name) [URLDecode $value]
#		} else {
			set cgi($name) [URLDecode $value]
			set cgilist($name) 0
#		}
		incr cgilist($name)
	}
	return [array names cgi]
}

#Adapted from Brent B. Welch, _Practical Programming in Tcl and Tk_
proc CGIValue {key} {
	global cgi
	if {[info exists cgi($key)]} {
		if {[mightBeUsedInFilename $key]} {
			return [sanitizePotentialFilenameElement $cgi($key)]
		} else {
			return $cgi($key)
		}
	} else {
		return {}
	}
}

#Cosmetically adapted from Brent B. Welch, _Practical Programming in Tcl and
#Tk_
proc CGILength {key} {
	global cgilist
	if {[info exist cgilist($key)]} {
		return $cgilist($key)
	} else {
		return 0
	}
}

proc CGIExists {key} {
	global cgi
	return [info exists cgi($key)]
}

#Cosmetically adapted from Brent B. Welch, _Practical Programming in Tcl and
#Tk_
proc CGIQuery {} {
	global env
	if {![info exists env(QUERY_STRING)] ||
			[string length $env(QUERY_STRING)] == 0} {
		if {[info exists env(CONTENT_LENGTH)] &&
				[string length $env(CONTENT_LENGTH)] != 0} {
			set query [read stdin $env(CONTENT_LENGTH)]
		} else {
			gets stdin query
		}
		set env(QUERY_STRING) $query
		set env(CONTENT_LENGTH) 0
	}
	return $env(QUERY_STRING)
}

#Cosmetically adapted from Brent B. Welch, _Practical Programming in Tcl and
#Tk_
proc URLDecode {url} {
	regsub -all {\+} $url { } url
	regsub -all {%([[:xdigit:]]{2})} $url \
		{[format %c 0x\1]} url
	return [subst $url]
}

#Slightly adapted from procedures e-mailed by Stuart Cassoff.
proc loadConfigFile {cfg_file} {
	 global configOptions configResult
     if {[catch {set f [open $cfg_file r]}]} {
	return 0
     }
     set buf {}
     set bad_buf {0}
     set keep_reading {1}
     set ok {0}
     while {1} {
	# Read in a chunk of data if there is any more to read
	if {$keep_reading} {
	    # Try to read more data into buf
	    if {[eof $f] || [catch {append buf [read $f 130]}]} {
		# Problem or eof
		# Stop reading, work with whatever we have
		set keep_reading 0
		# No reason to keep the file open at this point
		catch {close $f}
	    }
	}
	# How much data in buffer?
	set buf_len [string length $buf]
	# Done if no data
	if {$buf_len == 0} {
	    break
	}
	# Find newline
	set nl_pos [string first "\n" $buf]
	# No newline in buffer
	if {$nl_pos == -1} {
		# Following zero, one, infinity rule, I (Jonathan, Snippets/Sidebar) am
		# turning this off.
		set limitBufferLength 0
	    # Limit buffer size
	    # No newlines at this point means line too long
	    # or not proper config file.
	    # This will prevent using all memory
	    # if fed a gigantic file
	    if {($buf_len > 250) && ($limitBufferLength)} {
		# Clear buffer
		set buf {}
		incr bad_buf
		if {$bad_buf > 2} {
		    # 3 strikes yer out!
		    # At this point it is probably safe to
		    # assume that this is not a proper config file
		    set ok 0
		    break
		}
	    }
	    # Maybe newline coming soon if there is
	    # still more data to read
	    if {$keep_reading} {
		continue
	    }
	    # Hit eof or problem,
	    # buf has data but no newline
	    # Add newline and adjust nl_pos
	    append buf "\n"
	    set nl_pos [incr buf_len]
	}
	# Get line, discard (skip over) newline
	# Get trim(line) from buffer
	incr nl_pos -1
	set line [string trim [string range $buf 0 $nl_pos]]
	# Remove line from buffer
	incr nl_pos 2
	set buf [string range $buf $nl_pos end]
	# Skip empty or comment lines
	if {[string length $line] == 0 || [string equal [string index $line 0] "\#"]} {
	    continue
	}
	# Does this correspond to a valid option?
	set opt_name [lindex $line 0]
	set opt_pos [lsearch -exact $configOptions $opt_name]
	if {$opt_pos == -1} {
	    continue
	}
	# Set option
	set configResult($opt_name) [lindex $line 1]
	set ok 1
     }
     # May have already closed file
     if {$keep_reading} {
	catch {close $f}
     }
     return $ok
}

#Slightly adapted from procedures e-mailed by Stuart Cassoff.
#Not kept up to date with changes to other variable.
proc saveConfigFile {cfg_file cfg_arr {head {}} {foot {}}} {
	 global configOptions
     upvar \#0 $cfg_arr ca
     append cfg_data $head
     foreach opt $configOptions {
	append cfg_data [list $opt $ca($opt)] "\n"
     }
     append cfg_data $foot
     if {[catch {
	set f [open $cfg_file w]
	puts $f $cfg_data
	flush $f
	close $f
     } err]} {
	catch {close $f}
	return 0
     }
     return 1
}

#
# The routines below, and the main body, are more specific to Snippets/Sidebar.
#

proc accessError {} {
	logProcedureCall "accessError"
	puts -nonewline "<p>There's been an error.  The program that's making\n\
		these pages thinks you're trying to use it differently from how it's\n\
		set up.  You might tell the administrator what you were trying to\n\
		do, so that it can be fixed.</p>\n\
		\n\
		<p>Sorry!</p>\n"
	pageEnd
	# If I set an exit status of one, will that generate an internal server
	# error?
	exit 0
}

proc addTemplates {} {
	global metadata
	logProcedureCall "addTemplates"
	if {[CGIValue shouldAddTemplates] == "yes"} {
		readMetadata
		set previous [CGIValue previousPageMode]
		foreach key [CGIKeys] {
			switch -regexp $key {
				{^importtemplate_(.*)$} {
					regexp {^(.*?)_(.*)$} $key match prefix id
					set templateMetadata [readUserMetadata template]
					foreach current $templateMetadata {
						array set currentRow $current
						if {$currentRow(identifier) == $id} {
							lappend metadata $current
							getLock "[getFilePrefix]/users/[getUserName]/$id"
							file copy "[getFilePrefix]/users/template/$id"\
								"[getFilePrefix]/users/[getUserName]/$id"
							releaseLock\
								"[getFilePrefix]/users/[getUserName]/$id"
						}
					}
				}
			}
		}
	}
}

# Could be race conditions if two people try to create the same account name
# at the same time.
proc addUser {login password passwordDuplicate} {
	global passwords
	logProcedureCall "addUser"
	set loginValid 1
	set errorMessage ""
	getLock [getPasswordFilename]
	readPasswords
	# Make any e-mail validitiy checks
	if {$login != ""} {
		set index 0
		set shouldContinue 1
		while {$shouldContinue} {
			array set currentRow [lindex $passwords $index]
			if {$index >= [llength $passwords]} {
				set shouldContinue 0
			} else {
				if {$currentRow(login) == $login} {
					set loginValid 0
					releaseLock [getPasswordFilename]
					return 0
				}
			}
			incr index
		if {$password != $passwordDuplicate} {
			set loginValid 0
			releaseLock [getPasswordFilename]
			return 0
		}
	}
	if {$loginValid} {
		set newLogin(login) $login
		set newLogin(password) $password
		if {[getProgramMode] == "MagicNotebook"} {
			set newLogin(flags) "concise editlink"
		} else {
			set newLogin(flags) ""
		}
		set newLogin(parent) ""
		lappend passwords [array get newLogin]
		writePasswords
		file copy -force "[getFilePrefix]/users/template" \
		  "[getFilePrefix]/users/$login"
		}
	}
	releaseLock [getPasswordFilename]
	return 1
}

proc authenticate {} {
	logProcedureCall "authenticate"
	if {[authenticateInternal [CGIValue login] [CGIValue password]]} {
		return 1
	}
	if {[authenticateInternal [CGIValue login] [CGIValue changePasswordNew]]} {
		return 1
	}
	return 0
}

proc authenticateInternal {login password} {
	global passwords
	global userNotifiedOfLock
	logProcedureCall "authenticateInternal"
	readPasswords
	set index 0
	set shouldContinue 1
	if {(([shouldAllowGuestAccess] && $login == "guest") ||\
		(([getProgramMode] == "sidebar") && [shouldAllowSidebarAccess] &&\
		![CGIExists administrative]) ||\
		([shouldAllowWikiAccess] && $login == "wiki"))} {
		return 1
	}
	while {$shouldContinue} {
		array set currentRow [lindex $passwords $index]
		if {$index >= [llength $passwords]} {
			set shouldContinue 0
		} else {
			if {($currentRow(login) == $login) && ($currentRow(password) ==\
				$password)} {
				if {![testUserFlag $login "locked"]} {
					return 1
				} else {
					if {!($userNotifiedOfLock)} {
						set userNotifiedOfLock 1
						puts -nonewline "<h1>This account has been\
							locked.</h1>\
							\n\
							\n<p><strong>Please <a\
							href=\"mailto:[getServerAdminEmail]\">contact the\
							administrator</a> if you are unsure why this\
							account may be locked.</strong></p>\
							\n<hr>\n"
					}
					return 0
				}
			}
		}
		incr index
	}
	return 0
}

proc changePassword {userId password duplicate} {
	global passwords
	logProcedureCall "changePassword"
	getLock [getPasswordFilename]
	readPasswords
	if {[userExists $userId]} {
		if {$password == $duplicate} {
			set index 0
			set shouldContinue 1
			while {$shouldContinue} {
				array set currentRow [lindex $passwords $index]
				if {$index >= [llength $passwords]} {
					set shouldContinue 0
				} else {
					if {$currentRow(login) == $userId} {
						set currentRow(password) $password
						set passwords [lreplace $passwords $index $index\
							[array get currentRow]]
						writePasswords
						releaseLock [getPasswordFilename]
						return 1
					}
				}
				incr index
			}
		} else {
			releaseLock [getPasswordFilename]
			return 0
		}
	} else {
		releaseLock [getPasswordFilename]
		return 0
	}
}

proc checkForLogout {} {
	logProcedureCall "checkForLogout"
	if { [CGIValue pageMode] == "logout" || \
		[CGIValue logout_button] != "" || \
		[CGIValue logout_button.x] != "" || \
		[CGIValue logout_button.x] != "" } {
		readFile [concat [getFilePrefix]/general/logout]
		exit 0
	}
}
proc clearFlag {target flag} {
	logProcedureCall "clearFlag"
	if {[regexp -- "$flag" "$target"]} {
		regsub -all $flag $target {} target
		regsub -all {\s+} $target { } target
	}
	return $target
}

proc clearUserFlag {userId flag} {
	global passwords
	logProcedureCall "clearUserFlag"
	if {[userExists $userId]} {
		set index 0
		set shouldContinue 1
		while {$shouldContinue} {
			array set currentRow [lindex $passwords $index]
			if {$index >= [llength $passwords]} {
				set shouldContinue 0
			} else {
				if {$currentRow(login) == $userId} {
					set currentRow(flags) [clearFlag "$currentRow(flags)"\
						"$flag"]
					set passwords [lreplace $passwords $index $index [array\
						get currentRow]]
					writePasswords
					return 1
				}
			}
			incr index
		}
	}
	return 0
}

proc collapse {id} {
	global metadata
	logProcedureCall "collapse"
	readMetadata
	for {set index 0} {$index < [llength $metadata]} {incr index} {
		array set current [lindex $metadata $index]
		if {$current(identifier) == $id} {
			set current(flags) [clearFlag "$current(flags)" "expand"]
			set metadata [lreplace $metadata $index $index [array get current]]
		}
	}
}

proc collapseAllSiblingsOfAncestors {id} {
	global metadata
	logProcedureCall "collapseAllSiblingsOfAncestors"
	readMetadata
	set parent [getParent $id]
	for {set index 0} {$index < [llength $metadata]} {incr index} {
		array set current [lindex $metadata $index]
		if {$current(parent) == $parent} {
			if {$current(identifier) != $id} {
				collapse $current(identifier)
			}
		}
	}
	# Recursive step.
	if {$parent != "top"} {
		collapseAllSiblingsOfAncestors $parent
	}
}

# This could have race conditions if two people use the same account and try
# to make new folders at the same [clock clicks].
proc createFolder {{parent top}} {
	global metadata
	global shouldSortMetadata
	debugLog "createFolder"
	readMetadata
	set prefix "[getProgramMode]"
	set extension ""
	set newFolder(identifier) "$prefix[clock seconds][expr abs([clock\
		clicks])]$extension"
	set newFolder(title) "\[This folder has not been named. Please name it.\]"
	set newFolder(header) ""
	set newFolder(flags) "show expand folder"
	if {[getProgramMode] == "MagicNotebook"} {
		set newFolder(parent) "$parent"
	} else {
		set newFolder(parent) ""
	}
	lappend metadata [array get newFolder]
	writeMetadata 1
	if {[testUserFlag [getUserName] "concise"]} {
		collapseAllSiblingsOfAncestors $newFolder(identifier)
	}
	selectNote $newFolder(identifier)
	set shouldSortMetadata 1
	return $newFolder(identifier)
}

# This could have race conditions if two people try to make the same account
# at the same time.
proc createLogin {} {
	global passwords
	global shouldSortMetadata
	logProcedureCall "createLogin"
	getLock [getPasswordFilename]
	readPasswords
	set login [CGIValue newLogin]
	set password [CGIValue password]
	set passwordDuplicate [CGIValue passwordDuplicate]
	if {[shouldAllowLoginCreation]} {
		set loginValid 1
		set errorMessage ""
		# Make any e-mail validitiy checks that are desired--checking address
		# to have valid format.
		if {$login != ""} {
			set index 0
			set shouldContinue 1
			while {$shouldContinue} {
				array set currentRow [lindex $passwords $index]
				if {$index >= [llength $passwords]} {
					set shouldContinue 0
				} else {
					if {$currentRow(login) == $login} {
						set loginValid 0
						puts -nonewline "<p>Your e-mail address is already\
							registered.  Select \"Help! I forgot my\
							password.\" to have your password e-mailed\
							to you.</p>\n\
							<p><input type=\"radio\"\
							name=\"pageMode\" value=\"forgotPassword\"\
							onclick=\"document.[getProgramMode].submit()\"\
							checked> Help! I forgot my password.</p>\n\
							<p><input type=\"image\" name=\"Go!\"\ border=\"0\"
							src=\"[getDocumentURL]/submit.jpg\">\n</p>"
						pageEnd
						releaseLock [getPasswordFilename]
						exit 0
					}
				}
				incr index
			if {$password != $passwordDuplicate} {
				set loginValid 0
				puts -nonewline "<p>Passwords do not match.  Please make\
					sure that you type the exact same password, exactly the\
					same way, both times.</p>\n"
				displayCreateLogin
				pageEnd
				releaseLock [getPasswordFilename]
				exit 0
			}
		}
		if {$loginValid} {
			registerQueryData "login" "$login"
			registerQueryData "password" "$password"
			set newLogin(login) $login
			set newLogin(password) $password
			set newLogin(flags) "concise"
			set newLogin(parent) ""
			lappend passwords [array get newLogin]
			writePasswords
			file delete -force "[getFilePrefix]/users/$login"
			file copy -force "[getFilePrefix]/users/template" \
			  "[getFilePrefix]/users/$login"
			if {[getProgramMode] == "MagicNotebook"} {
				readMetadata
				sortMetadata
				writeMetadata 1
				puts "<input type=\"hidden\" name=\"login\" value=\"$login\">"
				puts "<input type=\"hidden\" name=\"password\"\
					value=\"$password\">"
				showMagicNotebook
				displayStandardChoices view 1
			} else {
				welcomeScreen $login $password
			}
			pageEnd
			releaseLock [getPasswordFilename]
			exit 0
			}
		} else {
			displayCreateLogin
			pageEnd
			releaseLock [getPasswordFilename]
			exit 0
		}
	}
	puts -nonewline "<p>This server is not presently set up to create\
		logins.</p>\n\
		<input type=\"hidden\" name=\"pageMode\" value=\"entryMenu\">\n\
		<p><input type=\"image\" name=\"Return to main menu\"\ border=\"0\"
		src=\"[getDocumentURL]/return_to_the_main_menu.jpg\"></p>" 
	registerQueryData "pageMode" "entryMenu"
	pageEnd
	releaseLock [getPasswordFilename]
	exit 0
}

# This could have race conditions if two people use the same account and try
# to make new notes at the same [clock clicks].
proc createNote {{parent top}} {
	global metadata
	global shouldSortMetadata
	logProcedureCall "createNote"
	set prefix "[getProgramMode]"
	set extension ""
	set newNote(identifier) "$prefix[clock seconds][expr abs([clock\
		clicks])]$extension"
	set newNote(title) "\[This note has not been named. Please name it.\]"
	set newNote(header) ""
	set newNote(flags) "show"
	if {[getProgramMode] == "MagicNotebook"} {
		set newNote(flags) "$newNote(flags) selected expand"
		set newNote(parent) "$parent"
	} else {
		set newNote(parent) ""
	}
	lappend metadata [array get newNote]
	set fullFilename "[getFilePrefix]/users/[getUserName]/$newNote(identifier)"
	selectNote $newNote(identifier)
	if { [catch {open $fullFilename w} fileId] } {
		logMessage "Couldn't open file $fullFilename. Exiting from createNote... $fileId"
		panic
	} else {
		puts $fileId "\"\""
		close $fileId
	}
	if {[testUserFlag [getUserName] "concise"]} {
		collapseAllSiblingsOfAncestors $newNote(identifier)
	}
	#set shouldSortMetadata 1
	sortMetadata
	writeMetadata 1
	return $newNote(identifier)
}

proc debugLog {message} {
	global debugMode
	if {$debugMode} {
		logMessage $message
	}
}

proc deleteFolder {identifier} {
	global metadata
	logProcedureCall "deleteFolder"
	if {[isFolder $identifier]} {
		foreach current $metadata {
			array set currentRow $current
			if {$currentRow(parent) == $identifier} {
				if {[isFolder $currentRow(identifier)]} {
					deleteFolder $currentRow(identifier)
				}
				if {[isNote $currentRow(identifier)]} {
					deleteNote $currentRow(identifier)
				}
			}
		}
		deleteFromMetadata $identifier
	} else {
		logProcedureCall "deleteFolder called on an identifier which was not a folder."
	}
}

proc deleteFromMetadata {identifier} {
	global metadata
	for {set index 0} {$index < [llength $metadata]} {incr index} {
		array set currentRow [lindex $metadata $index]
		if {$currentRow(identifier) == $identifier} {
			set metadata [lreplace $metadata $index $index]
		}
	}
}

proc deleteNote {identifier} {
	logProcedureCall "deleteNote"
	if {[isNote $identifier]} {
		file delete "[getFilePrefix]/users/[getUserName]/$identifier"
		deleteFromMetadata $identifier
	} else {
		logMessage "deleteNote called on an identifier which was not a\
			note."
	}
}

proc deleteUser {userId} {
	global passwords
	global administrativeActionResult
	logProcedureCall "deleteUser"
	getLock [getPasswordFilename]
	readPasswords
	if {[userExists $userId]} {
		set index 0
		set shouldContinue 1
		while {$shouldContinue} {
			array set currentRow [lindex $passwords $index]
			if {$index >= [llength $passwords]} {
				set shouldContinue 0
			} else {
				if {$currentRow(login) == $userId} {
					set passwords [lreplace $passwords $index $index]
				}
			}
			incr index
		}
		writePasswords
		foreach filename [glob [getFilePrefix]/users/$userId] {
			file delete -force $filename
		}
		file delete -force "[getFilePrefix]/users/$userId"
		set administrativeActionResult "<p>User <em>$userId</em> successfully\
			deleted.</p>\n"
	} else {
		set administrativeActionResult "<p>Error: user <em>$userId</em> does\
			not exist and therefore could not be deleted.</p>\n"
	}
	releaseLock [getPasswordFilename]
}

proc deregisterLock {filename} {
	global lockedFiles
	logProcedureCall "deregisterLock"
	while {[lsearch -exact $lockedFiles $filename] != -1} {
		set index [lsearch -exact $lockedFiles $filename]
		set lockedFiles [lreplace $lockedFiles $index $index]
	}
}

proc displayCreateLogin {} {
	logProcedureCall "displayCreateLogin"
	puts -nonewline "<p>E-mail address:<br>\n\
		<input type=\"text\" name=\"newLogin\"\
		size=\"[getTextWidth]\"></p>\n\
		<p>Password:<br>\n\
		<input type=\"password\" name=\"password\"\
		size=\"[getTextWidth]\"></p>\n\
		<p>Repeat password:<br>\n\
		<input type=\"password\" name=\"passwordDuplicate\"\
		size=\"[getTextWidth]\"></p>\n\
		<p>We need your e-mail address so we can send you your\
		password if it is ever lost.  (What's the\
		<a href=\"[getDocumentURL]/privacy.html\"\
		target=\"_blank\">privacy policy</a> about\
		this?)</p>\n\
		<p>Children under 13 must get their parents'\
		permission to set up an account (this is legally\
		required in the U.S., where this software was written).</p>\n\
		<input type=\"hidden\" name=\"pageMode\"\
		value=\"createLogin\">\n\
		<p><input type=\"image\" name=\"Go!\"\ border=\"0\"
		src=\"[getDocumentURL]/submit.jpg\"></p>\n"
	registerQueryData "pageMode" "createLogin"
}

# Here we break all sorts of good software engineering practice to optimize.
# More specifically, we want to avoid costly procedure calls as much as
# possible, and so we break various sorts of encapsulation.
#
# This is one of a few areas where optimization is needed.
proc displayForParent {parentName {htmlPrefix ""}} {
	global additionalQueryData
	global metadata
	global pageModeResult
	logProcedureCall "displayForParent"
	set actionURL [getActionURL]
	set cellPadding [getCellPadding]
	if {$pageModeResult == "metaSnippets"} {
		set cellPadding 0
	}
	set documentURL [getDocumentURL]
	set closedFolderIconFilename "$documentURL/closed_folder.gif"
	set closedNoteIconFilename "$documentURL/closed_topic.gif"
	set editLinks [testUserFlag [getUserName] "editlink"]
	set openFolderIconFilename "$documentURL/open_folder.gif"
	set openNoteIconFilename "$documentURL/open_topic.gif"
	set shadowIconFilename "$documentURL/shadow.gif"
	set wideShadowIconFilename "$documentURL/wideshadow.gif"
	foreach field [getWithParent $parentName] {
		set metadataFlags ""
		set noteName ""
		foreach currentPacked $metadata {
			array set currentUnpacked $currentPacked
			if {$currentUnpacked(identifier) == $field} {
				set metadataFlags $currentUnpacked(flags)
				set noteName $currentUnpacked(title)
			}
		}
		if {[regexp -- "show" $metadataFlags] || \
		  $pageModeResult == "metaSnippets"} {
			puts "$htmlPrefix<table border=\"0\" cellspacing=\"0\"\
			  cellpadding=\"$cellPadding\">\n<tr>\n"
			if {$pageModeResult == "view" || $pageModeResult == "connect" || \
				[CGIValue pageMode] == "createLogin"} {
				puts "$htmlPrefix<td>"
				if {[regexp -- "expand" $metadataFlags]} {
					puts -nonewline "$htmlPrefix<a class=\"titlelink\"\
					  href=\"$actionURL?pageMode=view&note=$field&action=collapse_$field&$additionalQueryData\">"
					if {[regexp -- "folder" $metadataFlags]} {
						puts "<img src=\"$openFolderIconFilename\"\
						  border=\"0\" alt=\"\"></a>"
					} else {
						puts "<img src=\"$openNoteIconFilename\"\
						  border=\"0\" alt=\"\"></a>"
					}
				} else {
					puts -nonewline "$htmlPrefix<a class=\"titlelink\"\
					  href=\"$actionURL?pageMode=view&note=$field&action=expand_$field&$additionalQueryData\">"
					if {[regexp -- "folder" $metadataFlags]} {
						puts "<img src=\"$closedFolderIconFilename\"\
						  border=\"0\" alt=\"\"></a>"
					} else {
						puts "<img src=\"$closedNoteIconFilename\"\
						  border=\"0\" alt=\"\"></a>"
					}
				}
				puts "$htmlPrefix</td><td>"
				if {$editLinks} {
					if {[regexp -- "folder" $metadataFlags]} {
						puts -nonewline "$htmlPrefix<a class=\"titlelink\"\
							href=\"$actionURL?$additionalQueryData&pageMode=metaSnippetsAction&action=editfolder_$field\">"
						} else {
							puts -nonewline "$htmlPrefix<a
								class=\"titlelink\"\
								href=\"$actionURL?$additionalQueryData&pageMode=metaSnippetsAction&action=editnote_$field\">"
						}
				} else {
					if {[regexp -- "expand" $metadataFlags]} {
						puts -nonewline\
						  "$htmlPrefix<a class=\"titlelink\"\
						  href=\"$actionURL?pageMode=view&note=$field&action=collapse_$field&$additionalQueryData\">"
					} else {
						puts -nonewline\
						  "$htmlPrefix<a class=\"titlelink\"\
						  href=\"$actionURL?pageMode=view&note=$field&action=expand_$field&$additionalQueryData\">"
					}
				}
			} else {
				puts "$htmlPrefix<td>"
				if {[regexp -- "folder" $metadataFlags]} {
					puts -nonewline "$htmlPrefix<a class=\"titlelink\"\
						href=\"$actionURL?$additionalQueryData&pageMode=metaSnippetsAction&action=editfolder_$field\">"
					} else {
						puts -nonewline "$htmlPrefix<a
							class=\"titlelink\"\
							href=\"$actionURL?$additionalQueryData&pageMode=metaSnippetsAction&action=editnote_$field\">"
					}
			}
			puts "$noteName</a></td></tr>"
			if {[regexp -- "expand" $metadataFlags] || $pageModeResult ==
			"metaSnippets"} {
				if {$pageModeResult == "metaSnippets"} {
					puts "$htmlPrefix<tr><td width=\"50\"><img src=\"$shadowIconFilename\"\
					  border=\"0\"></td>"
				} else {
					puts "$htmlPrefix<tr><td><img src=\"$shadowIconFilename\"\
					  border=\"0\"></td>"
				}
				if {[regexp -- "expand" $metadataFlags] || \
				  $pageModeResult == "metaSnippets"} {
					if {[regexp -- "folder" $metadataFlags]} {
						puts -nonewline "$htmlPrefix<td>"
						displayForParent $field "	$htmlPrefix"
						puts -nonewline "</td>"
					} else {
						if {$pageModeResult != "metaSnippets" && \
						  $pageModeResult != "metaSnippetsAction"} {
							puts -nonewline "$htmlPrefix<td>"
							printHeader $field
							printSnippet $field
							puts -nonewline "</td>"
						}
					}
				}
				puts "$htmlPrefix</tr>"
				}
			puts "$htmlPrefix</table>"
		}
	}
}

proc displayLogin {} {
	logProcedureCall "displayLogin"
	puts -nonewline "<p>E-mail address:<br>\n\
		<input type=\"text\" name=\"login\"\
		size=\"[getTextWidth]\"></p>\n\
		<p>Password:<br>\n\
		<input type=\"password\" name=\"password\"\
		size=\"[getTextWidth]\"></p>\n\
		<input type=\"hidden\" name=\"pageMode\"\
		value=\"view\">\n\
		<p><input type=\"image\" name=\"Log in!\"\ border=\"0\"
		src=\"[getDocumentURL]/login.jpg\"></p>\n"
		registerQueryData "pageMode" "view"
}

proc displayMoveMenu {identifier} {
	global metadata
	logProcedureCall "displayMoveMenu"
	set items {}
	foreach currentPacked $metadata {
		array set currentUnpacked $currentPacked
		if {[isFolder $currentUnpacked(identifier)] && \
		  ![isDescendant $currentUnpacked(identifier) $identifier]} {
		  lappend items $currentUnpacked(identifier)
		}
	}
	set items [entrySort $items fullPathname]
	puts -nonewline "<p>Move to: <select name=\"motion\"\
	  onclick=\"document.[getProgramMode].submit()\">\
	  <option value=\"notebookMove_noop_noop\" selected>Don't move this\
	  anywhere.</option>\n\
	  <option value=\"notebookMove_"
	puts -nonewline $identifier
	puts "_top\">Outside of all folders.</option>"
	foreach destination $items {
		puts -nonewline "<option\
		  value=\"notebookMove_"
		puts -nonewline $identifier
		puts "_$destination\"\
		  >[getFullPath $destination]</option>"
	}
	puts "</select></p>"
}

proc displayNewFolderMenu {} {
	global metadata
	logProcedureCall "displayNewFolderMenu"
	set items {}
	foreach currentPacked $metadata {
		array set currentUnpacked $currentPacked
		if {[isFolder $currentUnpacked(identifier)]} {
			lappend items $currentUnpacked(identifier)
		}
	}
	set items [entrySort $items fullPathname]
	puts -nonewline "<p>Add a new folder to: <select name=\"newfolder\"\
	  onclick=\"document.[getProgramMode].submit()\">\
	  <option value=\"newfolder_noop\" selected>Don't add a new\
	  folder.</option>\n\
	  <option value=\"newfolder_top\">Outside of all folders.</option>"
	foreach destination $items {
		puts -nonewline "<option\
		  value=\"newfolder_$destination\"\
		  >[getFullPath $destination]</option>"
	}
	puts "</select></p>"
}

proc displayNewNoteMenu {} {
	global metadata
	logProcedureCall "displayNewNoteMenu"
	set items {}
	foreach currentPacked $metadata {
		array set currentUnpacked $currentPacked
		if {[isFolder $currentUnpacked(identifier)]} {
			lappend items $currentUnpacked(identifier)
		}
	}
	set items [entrySort $items fullPathname]
	puts -nonewline "<p>Add a new note to: <select name=\"newnote\"\
	  onclick=\"document.[getProgramMode].submit()\">\
	  <option value=\"newnote_noop\" selected>Don't add a new note.</option>\
	  <option value=\"newnote_top\">Outside of all folders.</option>"
	foreach destination $items {
		puts -nonewline "<option\
		  value=\"newnote_$destination\"\
		  >[getFullPath $destination]</option>"
	}
	puts "</select></p>"
}

proc displaySearchResults {} {
    logProcedureCall "displaySearchResults"
    set searchResults [getSearchResults]
    if {$searchResults == {}} {
        puts -nonewline "<h2>Searching for \"[CGIValue searchQuery]\" didn't \
          find anything.</h2>"
    } else {
        puts -nonewline "<h2>Search results for \"[CGIValue\
          searchQuery]\":</h2>\n"
        puts -nonewline "<blockquote>\n"
        puts -nonewline "<p>\n"
        foreach match $searchResults {
            getExpandLinkBeginning $match
            puts -nonewline "[getFullPath $match]</a><br>\n"
        }
        puts -nonewline "</p>\n"
        puts -nonewline "</blockquote>\n"
    }
}

proc displayStandardChoices {{displayMode view} {checked 0}} {
	logProcedureCall "displayStandardChoices"
	if {[CGIValue accessMethod] == "guest"} {
		puts -nonewline "<p><input type=\"image\" name=\"logout_button\"\
			border=\"0\" src=\"[getDocumentURL]/logout.jpg\"></p>\n"
		return
	}
	puts "<br>\n<hr>\n<p>"
    if {$displayMode == "search"} {
        puts "<input type=\"radio\" name=\"pageMode\" value=\"search\" \
          onclick=\"document.[getProgramMode].submit()\"\
          checked> \
          Search for: <input type=\"text\" name=\"searchQuery\" \
          size=\"[expr [getTextWidth] - 20]\" \
          value=\"[CGIValue searchQuery]\"><br>"
    } else {
        puts "<input type=\"radio\" name=\"pageMode\" value=\"search\" \
          onclick=\"document.[getProgramMode].submit()\"\
          > \
          Search for: <input type=\"text\" name=\"searchQuery\" \
          size=\"[expr [getTextWidth] - 20]\"><br>"
    }
	if {$displayMode == "view"} {
		if {[getProgramMode] != "MagicNotebook"} {
			puts -nonewline "<input type=\"radio\" name=\"pageMode\"\
				value=\"view\" "
			if {$checked} {
				puts -nonewline "checked "
			}
			puts -nonewline\
				"onclick=\"document.[getProgramMode].submit()\"\
				>\n"
			puts -nonewline "Show another [getProgramName] page.<br>\n"
		}
	}
	if {$displayMode != "view"} {
		puts "<input type=\"radio\" name=\"pageMode\" value=\"view\"\n\
			onclick=\"document.[getProgramMode].submit()\""
		if {$checked && $displayMode != "search"} {
			puts -nonewline " checked"
		}
		puts -nonewline "> Go to the viewing page.<br>"
	}
	if {$displayMode != "metaSnippet"} {
		puts -nonewline "<input type=\"radio\" name=\"pageMode\" value=\"metaSnippets\"\
			onclick=\"document.[getProgramMode].submit()\""
		if {[getProgramMode] == "MagicNotebook" && $displayMode == "view" &&
			$checked} {
			puts -nonewline "checked"
		}
		puts -nonewline ">\n\
			Edit what appears on the [getProgramName] page.<br>\n"
	}
	if {$displayMode != "accountManagement"} {
		switch [getUserName] {
			guest -
			wiki {
			}
			default {
				puts -nonewline "<input type=\"radio\" name=\"pageMode\"\
					value=\"accountManagement\"\
					onclick=\"document.[getProgramMode].submit()\"\
					>\n\
					Change your password or configure the behavior of these\
					pages.<br>\n"
			}
		}
	}
	if {[isAdministrator [getUserName]]} {
		puts -nonewline "<input type=\"radio\" name=\"pageMode\"\
			value=\"administrative\"\
			onclick=\"document.[getProgramMode].submit()\"\
			> Use administrative tools.<br>"
	}
	puts -nonewline "<input type=\"radio\" name=\"pageMode\" value=\"logout\"\
		onclick=\"document.[getProgramMode].submit()\">\n"
	puts -nonewline "Log out from [getProgramNameWithArticle].<br>\n"
	puts -nonewline "</p>\n<p><input type=\"image\" name=\"Go!\"\ border=\"0\"
		src=\"[getDocumentURL]/submit.jpg\"></p>\n"
}

proc editDisplayForParent {parentName {htmlPrefix ""}} {
	global additionalQueryData
	global metadata
	global pageModeResult
	logProcedureCall "editDisplayForParent"
	set actionURL [getActionURL]
	set documentURL [getDocumentURL]
	set closedFolderIconFilename "$documentURL/closed_folder.gif"
	set closedNoteIconFilename "$documentURL/closed_topic.gif"
	set editLinks [testUserFlag [getUserName] "editlink"]
	set openFolderIconFilename "$documentURL/open_folder.gif"
	set openNoteIconFilename "$documentURL/open_topic.gif"
	set shadowIconFilename "$documentURL/shadow.gif"
	set wideShadowIconFilename "$documentURL/wideshadow.gif"
	foreach field [getWithParent $parentName] {
		set metadataFlags ""
		set noteName ""
		foreach currentPacked $metadata {
			array set currentUnpacked $currentPacked
			if {$currentUnpacked(identifier) == $field} {
				set metadataFlags $currentUnpacked(flags)
				set noteName $currentUnpacked(title)
			}
		}
		if {[regexp -- "folder" $metadataFlags]} {
			puts -nonewline "$htmlPrefix<a class=\"titlelink\"\
			  href=\"[getActionURL]?$additionalQueryData&pageMode=metaSnippetsAction&action=editfolder_$field\">"
		} else {
			puts -nonewline "<a class=\"titlelink\"\
			  href=\"[getActionURL]?$additionalQueryData&pageMode=metaSnippetsAction&action=editnote_$field\">"
		}
		puts "$noteName $field</a>"
		#puts "$htmlPrefix<table border=\"0\" cellspacing=\"0\"\
		#	cellpadding=\"0\"><tr><td height=\"1\"\
		#	width=\"100%\" colspan=\"2\"> </td></tr>\
		#	<tr><td> <img\
		#	src=\"$wideShadowIconFilename\" border=\"0\"></td>"
		puts "$htmlPrefix<table border=\"0\" cellspacing=\"0\"\
			cellpadding=\"0\"><tr><td height=\"1\"\
			width=\"100%\" colspan=\"2\"> </td></tr><tr><td><img\
			src=\"$wideShadowIconFilename\" border=\"0\"></td>"
		if {[regexp -- "folder" $metadataFlags]} {
			puts -nonewline "$htmlPrefix<td>"
			editDisplayForParent $field "	$htmlPrefix"
			puts -nonewline "</td>"
		} else {
			puts "$htmlPrefix</tr></table>"
		}
	}
}

proc editFolder {identifier} {
	logProcedureCall "editFolder"
	expandAppropriately $identifier
	puts -nonewline "<input type=\"hidden\" name=\"note\"\
		value=\"$identifier\">\n\
		<input type=\"hidden\" name=\"pageMode\" value=\"metaSnippetsAction\">\n\
		<h2>Folder</h2>\n"
	registerQueryData "note" $identifier
	registerQueryData "pageMode" "metaSnippetsAction"
	puts -nonewline "<p><input type=\"text\" name=\"title_$identifier\"\
		size=\"[getTextWidth]\" value=\"[quoteHtmlMetacharacters [getNoteName\
		$identifier]]\"></p>\n"
	puts -nonewline "<hr>\
		<p><input type=\"radio\" name=\"shouldsave\" value=\"yes\" checked>\
		Save any changes.<br>\n\
		<input type=\"radio\" name=\"shouldsave\" value=\"no\">\
		Discard any changes.</p>\n\
		<hr>\n"
	displayMoveMenu $identifier
	puts -nonewline "<hr>\n"
	if {[testMetadataFlag $identifier "show"]} {
		puts "<p><input type=\"radio\" name=\"action\"\
			value=\"hide_$identifier\"\
			onclick=\"document.[getProgramMode].submit()\"\
			>\
			Hide this folder from the main viewing page.<br>"
	} else {
		puts "<p><input type=\"radio\" name=\"action\"\
			value=\"show_$identifier\"\
			onclick=\"document.[getProgramMode].submit()\"\
			>\
			Show this folder from the main viewing page.<br>"
	}
	puts "<input type=\"radio\" name=\"action\"\
		value=\"newSubFolder\"\
		onclick=\"document.[getProgramMode].submit()\"\
		>\n\
		Add a new folder to this folder.<br>\
		<input type=\"radio\" name=\"action\"\
		value=\"newSubNote\"\
		onclick=\"document.[getProgramMode].submit()\"\
		>\n\
		Add a new note to this folder.</p>\n\
		<hr>\n"
	puts -nonewline "<p><input type=\"radio\" name=\"action\"\
		onclick=\"document.[getProgramMode].submit()\"\
		value=\"view\" checked> Go to the viewing page.<br>\
		<input type=\"radio\" name=\"action\" value=\"metaSnippets\"\
		onclick=\"document.[getProgramMode].submit()\">\
		Go to the editing page.<br>
		<input type=\"radio\" name=\"action\"
		onclick=\"document.[getProgramMode].submit()\"\
		value=\"accountManagement\"> Change your password or configure the\
		behavior of these pages."
	if {[isAdministrator [getUserName]]} {
		puts -nonewline "<br><input type=\"radio\" name=\"action\"\
			value=\"administrative\"\
			onclick=\"document.[getProgramMode].submit()\"\
			> Use administrative tools."
	}
	puts -nonewline "</p>"
	puts -nonewline "<hr>\
		<p><input type=\"radio\" name=\"action\"\
		value=\"deletefolder_$identifier\"> DELETE this folder and everything\
		in it.</p><hr>"
	puts -nonewline "<p><input type=\"image\" name=\"Go!\"\ border=\"0\"
		src=\"[getDocumentURL]/submit.jpg\"></p>\n"
}
proc editNote {identifier} {
	logProcedureCall "editNote"
	expandAppropriately $identifier
	puts -nonewline "<input type=\"hidden\" name=\"note\"\
		value=\"$identifier\">\n\
		<input type=\"hidden\" name=\"pageMode\" value=\"metaSnippetsAction\">\n\
		<h2>Note</h2>\n"
	registerQueryData "note" $identifier
	registerQueryData "pageMode" "metaSnippetsAction"
	if {[getProgramMode] == "sidebar"} {
		puts -nonewline "<p>This note name will be visible to you when you\
			edit this page, but not to your visitors. Use the header, below,\
			to put any desired HTML before items in this note.</p>\n"
	}
	puts -nonewline "<p><input type=\"text\" name=\"title_$identifier\"\
		size=\"[getTextWidth]\" value=\"[quoteHtmlMetacharacters [getNoteName\
		$identifier]]\"></p>\n"
	if {[getProgramMode] == "MagicNotebook"} {
		puts -nonewline "<h2>This Note's Text</h2>\n"
		puts -nonewline "<p><textarea name=\"header_$identifier\"\
			rows=\"[getTextHeight]\"\n"
	} else {
		puts -nonewline "<h2>Header</h2>\n\
			<p>This header, if any, will appear before each view.</p>\n"
		puts -nonewline "<p><textarea name=\"header_$identifier\" rows=\"3\"\n"
	}
	puts -nonewline "cols=\"[getTextWidth]\"\
		wrap=\"soft\">[quoteHtmlMetacharacters\
		[getHeader $identifier]]</textarea></p>"
	set note [readNote $identifier]
	if {[getProgramMode] != "MagicNotebook" || [testUserFlag [getUserName]\
	  "editsnippets"] || [llength $note] > 0} {
		if {[getProgramMode] == "MagicNotebook"} {
			puts -nonewline "<h2>Random Text</h2>\n\
				<p>The Magic Notebook can display random text under what you\
				type above. If you would like a randomly chosen quote to\
				appear, type the first thing in the box below, and then click\
				on \"Continue editing this note\" for as many other things as\
				you would like to see.</p>\n"
		} else {
			puts "<h2>Entries:</h2>"
		}
		set newIndex 0
		if {[llength $note] > 0} {
			for {set index 0} {$index < [llength $note]} {incr index} {
				set entry [lindex $note $index]
				puts -nonewline "<p><textarea name=\"value_$identifier"
				puts -nonewline "_$index\" rows=\"3\" cols=\"[getTextWidth]\"\
				  wrap=\"soft\">"
				puts -nonewline [quoteHtmlMetacharacters $entry]
				puts -nonewline "</textarea><br>\n\
					<input type=\"checkbox\" name=\"delete_$identifier"
				puts -nonewline "_$index\">Delete this entry</p>\n"
			}
			set newIndex $index
		}
		puts -nonewline "<h2>Add new entry:</h2>\n\
			<p><textarea name=\"value_$identifier"
		puts -nonewline "_$newIndex\" rows=\"5\""
		puts -nonewline "cols=\"[getTextWidth]\" wrap=\"soft\"></textarea></p>\n"
		}
	puts -nonewline "\
		<hr>\n\
		<p><input type=\"radio\" name=\"shouldsave\" value=\"yes\" checked>\
		Save any changes.<br>\n\
		<input type=\"radio\" name=\"shouldsave\" value=\"no\">\
		Discard any changes.</p>\n\
		<hr>\n"
	if {[getProgramMode] == "MagicNotebook"} {
		displayMoveMenu $identifier
		puts -nonewline "<hr>\n"
	}
	puts -nonewline "<p><input type=\"radio\" name=\"action\" value=\"view\"\n\
		onclick=\"document.[getProgramMode].submit()\"\
		checked> Go to the viewing page.<br>\n"
	puts -nonewline "<input type=\"radio\" name=\"action\"\
		value=\"metaSnippets\"\
		onclick=\"document.[getProgramMode].submit()\">\
		Go to the editing menu.<br>\n"
	if {[getProgramMode] == "MagicNotebook"} {
		puts -nonewline \
			"<input type=\"radio\" name=\"action\"\n\
			value=\"editnote_$identifier\"\
			onclick=\"document.[getProgramMode].submit()\"\
			> Continue editing this note.<br>\n"
	}
	if {[getProgramMode] == "MagicNotebook"} {
		if {[testMetadataFlag $identifier "show"]} {
		puts -nonewline "<input type=\"radio\" name=\"action\"\n\
			value=\"hide_$identifier\"
			onclick=\"document.[getProgramMode].submit()\"\
			> Hide this note from the main viewing page.<br>"
		} else {
		puts -nonewline "<input type=\"radio\" name=\"action\"\n\
			value=\"show_$identifier\"
			onclick=\"document.[getProgramMode].submit()\"\
			> Show this note from the main viewing page.<br>"
		}
	} else {
		puts -nonewline \
			"<p><input type=\"radio\" name=\"action\"\n\
			value=\"editnote_$identifier\"\
			onclick=\"document.[getProgramMode].submit()\"\
			> Continue editing this note.<br>\n"
	}
	puts -nonewline "<input type=\"radio\" name=\"action\"
		onclick=\"document.[getProgramMode].submit()\"\
		value=\"accountManagement\"> Change your password or \
		configure the behavior of these pages."
	if {[isAdministrator [getUserName]]} {
		puts -nonewline "<br><input type=\"radio\" name=\"action\"\
			value=\"administrative\"\
			onclick=\"document.[getProgramMode].submit()\"\
			> Use administrative tools."
	}
	puts -nonewline "</p>"
	puts -nonewline "<hr>\
		<p><input type=\"radio\" name=\"action\"\
		value=\"deletenote_$identifier\"> DELETE this note.</p>\
		<hr>\
		<p><input type=\"image\" name=\"Go!\"\ border=\"0\"
		src=\"[getDocumentURL]/submit.jpg\"></p>\n"
}

proc entrySort {toSort {criterionToSortOn "noteName"}} {
	global metadata
	logProcedureCall "entrySort"
	# Randomized QuickSort implemented after bubble sort took too long.
	# We append the internal name to the external key so the output
	# will always be in the same order, i.e. two fields with the same
	# name won't appear in variable order.
	if {[llength $toSort] < 2} {
		return $toSort
	}
	set dividingKey [lindex $toSort [expr int( rand() * [llength \
	  $toSort] ) ] ]
	set lesserBin {}
	set greaterOrEqualBin {}
	switch $criterionToSortOn {
		fullPathname {
			set dividingFieldToCompare [getFullPath $dividingKey]
		}
		noteName -
		default {
			set dividingFieldToCompare [getNoteName $dividingKey]
		}
	}
	foreach current $toSort {
		if {$current != $dividingKey} {
			switch $criterionToSortOn {
				fullPathname {
					set currentFieldToCompare [getFullPath $current]
				}
				noteName -
				default {
					set currentFieldToCompare [getNoteName $current]
				}
			}
			# Sort on displayed field value, using the key as a tiebreaker
			# so as to have consistent behavior between two items of the same
			# key.
			if {[string compare -nocase $currentFieldToCompare \
			  $dividingFieldToCompare] < 0} {
				lappend lesserBin $current
			} elseif {[string compare -nocase $currentFieldToCompare \
			  $dividingFieldToCompare] > 0} {
				lappend greaterOrEqualBin $current
			} else {
				if {[string compare -nocase $current $dividingKey] < 0} {
					lappend lesserBin $current
				} else {
					lappend greaterOrEqualBin $current
				}
			}
		}
	}
	return [concat [entrySort $lesserBin $criterionToSortOn] $dividingKey\
	[entrySort $greaterOrEqualBin $criterionToSortOn]]
}

proc entrySortWithParent {parentID {criterionToSortOn "noteName"}} {
	logProcedureCall "entrySortWithParent"
	debugLog "eswp1 [clock clicks]"
	return [entrySort [getWithParent $parentID] $criterionToSortOn]
	debugLog "eswp2 [clock clicks]"
}

proc expand {id} {
	global metadata
	logProcedureCall "expand"
	readMetadata
	for {set index 0} {$index < [llength $metadata]} {incr index} {
		array set current [lindex $metadata $index]
		if {$current(identifier) == $id} {
			set current(flags) [setFlag "$current(flags)" "expand"]
			set metadata [lreplace $metadata $index $index [array get current]]
		}
	}
}

proc expandAppropriately {identifier} {
	global shouldExpandAppropriately
	logProcedureCall "expandAppropriately"
	if {$shouldExpandAppropriately} {
		if {[shouldExpandOnlySelected]} {
			collapseAllSiblingsOfAncestors $identifier
		}
		if {[getSelectedEntity] == $identifier &&
		  ![isNoteBeingCollapsed $identifier]} {
			expandOnlyNodeAndAllParents $identifier
		} else {
			collapse $identifier
		}
	}
}

proc expandOnlyNodeAndAllParents {nodeIdentifier} {
	global metadata
	logProcedureCall "expandOnlyNodeAndAllParents"
	foreach packedRow $metadata {
		array set currentRow $packedRow
		if {[isSiblingOfAncestor $currentRow(identifier) $nodeIdentifier] && \
          ![isAncestor $nodeIdentifier $currentRow(identifier)]} {
            collapse $currentRow(identifier)
		}
	}
	expandOnlyNodeAndAllParentsInternal $nodeIdentifier
}

proc expandOnlyNodeAndAllParentsInternal {nodeIdentifier} {
	global metadata
	logProcedureCall "expandOnlyNodeAndAllParentsInternal"
	expand $nodeIdentifier
	foreach packedRow $metadata {
		array set currentRow $packedRow
		if {$currentRow(identifier) == $nodeIdentifier} {
			expandOnlyNodeAndAllParentsInternal $currentRow(parent)
		}
	}
}

# Presently a noop filter.  May be modified to sanitize HTML, convert ASCII to
# HTML, and so on and so forth.
proc filterText {original} {
	logProcedureCall "filterText"
	if {[shouldAllowHtmlSnippets]} {
		if {[testUserFlag [getUserName] "text"]} {
			return [textToHtml $original]
		} elseif {[testUserFlag [getUserName] "html"]} {
			return $original
		} else {
			switch [getDefaultDisplayMethod] {
				"text" {
					return [textToHtml $original]
				}
				"html" {
					return "<p>$original</p>"
				}
				"mixed" -
				default {
					return "[lineBreaksToHtml $original]"
				}
			}
		}
	} else {
		return [textToHtml $original]
	}
}

proc forgotPassword {} {
	logProcedureCall "forgotPassword"
	puts -nonewline "<input type=\"hidden\" name=\"pageMode\"\
		value=\"retrievePassword\">\n\
		<p>Please type in the e-mail address that you used when creating your\
		account:</p>\n\
		<p><input type=\"text\" name=\"login\" size=\"[getTextWidth]\"></p>\n\
		<p><input type=\"image\" name=\"E-mail me my password\"\ border=\"0\"
		src=\"[getDocumentURL]/email_me_my_password.jpg\"></p>\n"
	registerQueryData "pageMode" "retrievePassword"
}

proc getActionURL {} {
	logProcedureCall "getActionURL"
	return [getConfigValue "actionURL" "/cgi-bin/[getProgramMode]"]
}

proc getCellPadding {} {
	logProcedureCall "getCellPadding"
	return [getConfigValue "cellpadding" "3"]
}

proc getClosedFolderIconFilename {} {
	logProcedureCall "getClosedFolderIconFilename"
	return "[getDocumentURL]/closed_folder.gif"
}

# Not [getDocumentURL]/closed_note.gif for reasons of backwards compatibility.
proc getClosedNoteIconFilename {} {
	logProcedureCall "getClosedNoteIconFilename"
	return "[getDocumentURL]/closed_topic.gif"
}

proc getCloseNoteNameTag {} {
	logProcedureCall "getCloseNoteNameTag"
	return ""
}

proc getCollapseLinkBeginning {identifier} {
	global additionalQueryData
	logProcedureCall "getCollapseLinkBeginning"
	puts -nonewline "<a class=\"titlelink\"\
	  href=\"[getActionURL]?pageMode=view&note=$identifier&action=collapse_$identifier&$additionalQueryData\">"
}

proc getConfigFilename {} {
	global configFilename
	logProcedureCall "getConfigFilename"
	return $configFilename
}

proc getConfigValue {key defaultValue} {
	global configResult
	logProcedureCall "getConfigValue"
	foreach candidateKey [array names configResult] {
		if {$candidateKey == $key} {
			return $configResult($key)
		}
	}
	return $defaultValue
}

proc getCurrentMtimeFilename {} {
	logProcedureCall "getCurrentMtimeFilename"
	return "[getFilePrefix]/general/current"
}

proc getCurrentReleaseNumber {} {
	global currentReleaseNumber
	logProcedureCall "getCurrentReleaseNumber"
	return $currentReleaseNumber
}

proc getCurrentVersionNumber {} {
	global currentVersionNumber
	logProcedureCall "getCurrentVersionNumber"
	return $currentVersionNumber
}

proc getDefaultAccessMethod {} {
	logProcedureCall "getDefaultAccessMethod"
	return [getConfigValue "defaultAccessMethod" "guest"]
}

proc getDefaultDisplayMethod {} {
	logProcedureCall "getDefaultDisplayMethod"
	return [getConfigValue "defaultDisplayMethod" "mixed"]
}

proc getDeletionMarker {} {
	logProcedureCall "getDeletionMarker"
	return "Scheduled for deletion 50mwrx34."
}

proc getDocumentURL {} {
	logProcedureCall "getDocumentURL"
	return [getConfigValue "documentURL" "/[getProgramMode]/"]
}

proc getEditLinkBeginning {identifier} {
	global additionalQueryData
	logProcedureCall "getEditLinkBeginning"
	if {[testMetadataFlag $identifier "folder"]} {
		puts -nonewline "<a class=\"titlelink\"\
		  href=\"[getActionURL]?$additionalQueryData&pageMode=metaSnippetsAction&action=editfolder_$identifier\">"
	} else {
		puts -nonewline "<a class=\"titlelink\"\
		  href=\"[getActionURL]?$additionalQueryData&pageMode=metaSnippetsAction&action=editnote_$identifier\">"
	}
}

proc getExpandLinkBeginning {identifier} {
	global additionalQueryData
	logProcedureCall "getExpandLinkBeginning"
	puts -nonewline "<a class=\"titlelink\"\
	  href=\"[getActionURL]?pageMode=view&note=$identifier&action=expand_$identifier&$additionalQueryData\">"
}

proc getFilePrefix {} {
	logProcedureCall "getFilePrefix"
	return [getConfigValue "filePrefix" "/var/www/[getProgramMode]/"]
}

proc getFullBaseURL {} {
	logProcedureCall "getFullBaseURL"
	return [getConfigValue "fullBaseURL" "http://127.0.0.1/cgi-bin/[getProgramMode]"]
}

proc getFullPath {id} {
	logProcedureCall "getFullPath"
	if {[getParent $id] != "top"} {
		return "[getFullPath [getParent $id]] -&gt; [getNoteName $id]"
	} else {
		return "[getNoteName $id]"
	}
}

proc getFullVersionNumber {} {
	logProcedureCall "getFullVersionNumber"
	return "[getCurrentVersionNumber]-[getCurrentReleaseNumber]"
}

proc getHeader {id} {
	global metadata
	logProcedureCall "getHeader"
	set index 0
	set shouldContinue 1
	while {$shouldContinue} {
		if {$index >= [llength $metadata]} {
			set shouldContinue 0
		} else {
			array set current [lindex $metadata $index]
			if {$current(identifier) == $id} {
				return $current(header)
			}
		}
		incr index
	}
	return ""
}

# Parts of this are intended to run quickly, to decrease the window of bad
# opportunity for a file to become corrupted.
proc getLock {filename} {
	logProcedureCall "getLock"
	# To address chicken-and-egg concerns.
	if {![file exists $filename]} {
		return
	}
	set currentMtimeFilename [getCurrentMtimeFilename]
	set lockTimeout [getLockTimeout]
	set startTime [clock seconds]
	if {[file exists "$filename.lock"]} {
		set shouldContinue 1
		while {$shouldContinue} {
			if { [catch {open "$currentMtimeFilename" w} fileId] } {
				logMessage "gl2 Couldn't open $currentMtimeFilename for\
					writing. $fileId"
				panic
			} else {
				close $fileId
			}
			if {[file exists "$filename.lock"]} {
				if { [catch {open "$currentMtimeFilename" w} fileId] } {
					logMessage "gl1 Couldn't open $filename.lock for writing.  $fileId"
					panic
				} else {
					close $fileId
				}
				if {[file mtime "$currentMtimeFilename"] -\
					[file mtime "$filename.lock"] > $lockTimeout} {
					# Assume it's timed out, and commandeer the lock for
					# ourselves.
					if { [catch {open "$filename.lock" w} fileId] } {
						logMessage "gl2 Couldn't open $filename.lock for\
							writing. $fileId"
						panic
					} else {
						close $fileId
					}
					logMessage "Commandeered lock for $filename."
					if { [catch {open "$filename.lock.commandeered" w} fileId] } {
						logMessage "gl1 Couldn't open $filename.lock.commandeered for writing.  $fileId"
						panic
					} else {
						close $fileId
					}
					registerLock $filename
					return
				}
			} else {
				if { [catch {open "$filename.lock" w} fileId] } {
					logMessage "gl3 Couldn't open $filename.lock for writing.  $fileId"
					panic
				} else {
					close $fileId
				}
				registerLock $filename
				return
			}
			if {[clock seconds] - $startTime < $lockTimeout} {
				set shouldContinue 0
			}
			after 10
		}
		# Assume it's timed out, and commandeer the lock for
		# ourselves.
		if { [catch {open "$filename.lock" w} fileId] } {
			logMessage "gl2 Couldn't open $filename.lock for\
				writing. $fileId"
			panic
		} else {
			close $fileId
		}
		registerLock $filename
		return
	} else {
		if { [catch {open "$filename.lock" w} fileId] } {
			logMessage "gl4 Couldn't open $filename.lock for writing. $fileId"
			panic
		} else {
			close $fileId
		}
		registerLock $filename
		return
	}
}

proc getLockTimeout {} {
	logProcedureCall "getLockTimeout"
	return [getConfigValue "lockTimeout" "30"]
}

proc getMailerCommand {login} {
	logProcedureCall "getMailerCommand"
	set login [removeShellMetacharacters $login]
	set template [getConfigValue "mailerCommand"\
		"/usr/bin/Mail LOGIN -s \"Your [getProgramName] password\""]
	regsub -- {LOGIN} $template $login template
	return $template
}

proc getMetadataFilename {} {
	logProcedureCall "getMetadataFilename"
	return [getUserMetadataFilename [getUserName]]
}

proc getNoteName {id} {
	global metadata
	logProcedureCall "getNoteName"
	set index 0
	set shouldContinue 1
	while {$shouldContinue} {
		if {$index >= [llength $metadata]} {
			set shouldContinue 0
		} else {
			array set current [lindex $metadata $index]
			if {$current(identifier) == $id} {
				if {$current(title) == ""} {
					return "\[This has not been named. Please name it.\]"
				} else {
					return $current(title)
				}
			}
		}
		incr index
	}
	return ""
}

proc getNotes {} {
	global metadata
	logProcedureCall "getNotes"
	readMetadata
	set result {}
	for {set index 0} {$index < [llength $metadata]} {incr index} {
		array set current [lindex $metadata $index]
		if {$current(identifier) != ""} {
			lappend result $current(identifier)
		}
	}
	return $result
}

proc getNumberOfNotes {} {
	logProcedureCall "getNumberOfNotes"
	global metadata
	return [llength $metadata]
}

proc getOpenFolderIconFilename {} {
	logProcedureCall "getOpenFolderIconFilename"
	return "[getDocumentURL]/open_folder.gif"
}

# Not [getDocumentURL]/open_note.gif for reasons of backwards compatibility.
proc getOpenNoteIconFilename {} {
	logProcedureCall "getOpenNoteIconFilename"
	return "[getDocumentURL]/open_topic.gif"
}

proc getOpenNoteNameTag {} {
	logProcedureCall "getOpenNoteNameTag"
	return ""
}

# Name does not reflect procedure's full functionality. First time, it also
# does significant processing.
proc getPageMode {} {
	global administrativeActionResult
	global actionObject
	global editCommand
	global pageModeHasBeenCalled
	global pageModeResult
	logProcedureCall "getPageMode"
	if {$pageModeHasBeenCalled} {
		return $pageModeResult
	}
	set pageModeHasBeenCalled 1
	set pageModeResult "view"
	set editCommand ""
	set rawMode [CGIValue pageMode]
	if {[CGIValue login] == "guest"} {
		set pageModeResult "connect"
		return $pageModeResult
	}
	switch $rawMode {
		"administrative" -
		"connect" -
		"createLogin" -
		"forgotPassword" -
		"retrievePassword" -
        "search" {
			set pageModeResult $rawMode
			return $pageModeResult
		}
		"view" {
			set action [CGIValue action]
			set pageModeResult $rawMode
			updateDisplayedData
			if {[CGIValue shouldsave] == "yes"} {
				saveSubmittedChanges
			}
			addTemplates
			set pageModeResult $rawMode
			return $pageModeResult
		}
		"accountManagement" {
			switch [CGIValue accountManagement] {
				"returnToSnippets" {
					set pageModeResult "view"
					return $pageModeResult
				}
				"addTemplates" -
				"changePassword" -
				"updateHtmlPreference" -
				default {
					processAccountManagement
					set pageModeResult "accountManagement"
					return $pageModeResult
				}
			}
		}
		"administrativeAction" {
			if {[isAdministrator [getUserName]]} {
				switch [CGIValue administrativeAction] {
					"addUser" -
					"changeUserPassword" -
					"deleteUser" -
					"grantAdministrativePriveleges" -
					"lockUser" -
					"revokeAdministrativePriveleges" -
					"resetUserFromTextOnly" -
					"setUserToTextOnly" -
					"unlockUser" {
						processAdministrativeAction
						set pageModeResult "administrative"
						return $pageModeResult
					}
					"switchUser" {
						if {[userExists [CGIValue switchUserId]]} {
							puts "<input type=\"hidden\"\
								name=\"effectiveUserId\"\ value=\"[CGIValue\
								switchUserId]\">"
							registerQueryData "effectiveUserID"\
							  [CGIValue switchUserId]
							puts "<p><strong>You are now using the program as\
								user <em>[CGIValue switchUserId]</em>.</p>"
							set pageModeResult "metaSnippets"
							return $pageModeResult
						} else {
							set administrativeActionResult "<p>There does not\
								appear to be a user <em>[CGIValue\
								switchUserId]</em>.  You might check your
								spelling.</p>"
							set pageModeResult "administrative"
							return $pageModeResult
						}
					}
					"listUsers" {
						set pageModeResult "listUsers"
						return $pageModeResult
					}
					"returnToSnippets" {
						set pageModeResult "view"
						return $pageModeResult
					}
				}
			} else {
				set pageModeResult "view"
				return $pageModeResult
			}
		}
		"metaSnippets" {
			updateDisplayedData
			if {[CGIValue shouldsave] == "yes"} {
				saveSubmittedChanges
			}
			set pageModeResult "metaSnippets"
			return $pageModeResult
		}
		"metaSnippetsAction" {
			updateDisplayedData
			set action [CGIValue action]
			switch -exact [CGIValue newfolder] {
				newfolder_noop -
				"" {
				}
				default {
					set action [CGIValue newfolder]
				}
			}
			switch -exact [CGIValue newnote] {
				newnote_noop {
				}
				"" {
				}
				default {
					set action [CGIValue newnote]
				}
			}
			switch -regexp $action {
				{^(.*?)_(.*)$} {
					regexp {^(.*?)_(.*)$} $action match editCommand \
						actionObject
					switch -exact -- $editCommand {
						edit {
							set pageModeResult "editSnippet"
							return $pageModeResult
						}
						editfolder {
							set pageModeResult "editFolder"
							return $pageModeResult
						}
						editnote {
							set pageModeResult "editNote"
							return $pageModeResult
						}
						hide {
							hide $actionObject
							set pageModeResult "view"
							return $pageModeResult
						}
						newfolder {
							if {$actionObject == "top"} {
								set pageModeResult "newFolder"
								return $pageModeResult
							} else {
								set pageModeResult "newSubFolder"
								return $pageModeResult
							}
						}
						newnote {
							if {$actionObject == "top"} {
								set pageModeResult "newNote"
								return $pageModeResult
							} else {
								set pageModeResult "newSubNote"
								return $pageModeResult
							}
						}
						show {
							show $actionObject
							set pageModeResult "view"
							return $pageModeResult
						}
						default {
							set pageModeResult "view"
							return $pageModeResult
						}
					}
				}
				{^accountManagement$} -
				{^administrative$} -
				{^metaSnippets$} -
				{^newFolder$} -
				{^newSubFolder$} -
				{^newSubNote$} -
				{^newNote$} -
				{^mainMenu$} {
					set pageModeResult $action
					return $pageModeResult
				}
				{^view$} -
				default {
					set pageModeResult "view"
					return $pageModeResult
				}
			}
		}
		default {
			switch [getProgramMode] {
				"sidebar" {
					if {[CGIExists administrative]} {
						set pageModeResult "connect"
						return $pageModeResult
					} else {
						set pageModeResult "sidebar"
						return $pageModeResult
					}
				}
				"view" -
				default {
					set pageModeResult "entryMenu"
					return $pageModeResult
				}
			}
		}
	}
}

proc getParent {identifier} {
	global metadata
	logProcedureCall "getParent"
	foreach currentPacked $metadata {
		array set currentUnpacked $currentPacked
		if {$currentUnpacked(identifier) == $identifier} {
			return $currentUnpacked(parent)
		}
	}
	# We shouldn't get here, but just in case:
	return "top"
}

proc getPassword {login} {
	global passwords
	logProcedureCall "getPassword"
	readPasswords
	set index 0
	set shouldContinue 1
	while {$shouldContinue} {
		array set currentRow [lindex $passwords $index]
		if {$index >= [llength $passwords]} {
			set shouldContinue 0
		} else {
			if {($currentRow(login) == $login)} {
				return $currentRow(password)
			}
		}
		incr index
	}
	return 0
}

proc getPasswordFilename {} {
	logProcedureCall "getPasswordFilename"
	return "[getFilePrefix]/general/access"
}

proc getProgramMode {} {
    logProcedureCall "getProgramMode"
	#return "snippets"
	#return "sidebar"
	return "MagicNotebook"
}

proc getProgramName {} {
    logProcedureCall "getProgramName"
	switch [getProgramMode] {
		MagicNotebook {
			return "Magic Notebook"
		}
		sidebar {
			return "Sidebar in a Can"
		}
		view {
			return "Snippets"
		}
	}
}

proc getProgramNameWithArticle {} {
    logProcedureCall "getProgramNameWithArticle"
	switch [getProgramMode] {
		MagicNotebook {
			return "the Magic Notebook"
		}
		default {
		return [getProgramName]
		}
	}
}

proc getProgramNameWithCapitalizedArticle {} {
    logProcedureCall "getProgramNameWithCapitalizedArticle"
	switch [getProgramMode] {
		MagicNotebook {
			return "The Magic Notebook"
		}
		default {
            return [getProgramName]
		}
	}
}

proc getVisitorsIP {} {
	global env
    logProcedureCall "getVisitorsIP"
	return [removeShellMetacharacters $env(REMOTE_ADDR)]
}

# Presently uses AND logic and searches note text and titles but not rotating
# text.

proc getSearchResults {} {
    global metadata
    logProcedureCall "getSearchResults"
    set splitQuery [split [CGIValue "searchQuery"] " "]
    set unsorted {}
    foreach currentPacked $metadata {
        array set currentUnpacked $currentPacked
        if {[isNote $currentUnpacked(identifier)]} {
            set isMatch 1
            foreach queryItem $splitQuery {
                if {!([string last [string tolower $queryItem] \
                  [string tolower $currentUnpacked(title)]] != -1 || \
                  [string last [string tolower $queryItem] \
                  [string tolower $currentUnpacked(header)]] != -1)} {
                    set isMatch 0
                }
            }
            if {$isMatch && ![hasHiddenAncestor \
              $currentUnpacked(identifier)]} {
                lappend unsorted $currentPacked
            }
        }
    }
    set sorted [sortMetadataInner $unsorted "fullPathname"]
    set result {}
    foreach currentPacked $sorted {
        array set currentUnpacked $currentPacked
        lappend result $currentUnpacked(identifier)
    }
    return $result
}

proc getSelectedEntity {} {
	global metadata
	logProcedureCall "getSelectedEntity"
	#return [CGIValue note]
	foreach currentPacked $metadata {
		array set currentUnpacked $currentPacked
		if {[testFlag $currentUnpacked(flags) "selected"]} {
			return $currentUnpacked(identifier)
		}
	}
	return ""
}

proc getServerAdminEmail {} {
	logProcedureCall "getServerAdminEmail"
	return [getConfigValue "serverAdminEmail" "webmaster@127.0.0.1"]
}

proc getShadowIconFilename {} {
	logProcedureCall "getShadowIconFilename"
	return "[getDocumentURL]/shadow.gif"
}

proc getSnippetFilename {note} {
	logProcedureCall "getSnippetFilename"
	return [concat [getFilePrefix]/users/[getUserName]/$note]
}

proc getTextHeight {} {
	logProcedureCall "getTextHeight"
	return [getConfigValue "textHeight" "10"]
}

proc getTextWidth {} {
	logProcedureCall "getTextWidth"
	return [getConfigValue "textWidth" "80"]
}

proc getUserMetadataFilename {userId} {
	global shouldSortMetadata
	logProcedureCall "getUserMetadataFilename"
	if {[CGIValue "accessMethod"] == "guest" || [CGIValue "login"] == "guest"} {
		if { \
			! ( [file exists\
			"[getFilePrefix]/users/guest/metadata-[getVisitorsIP]"] ) ||\
			( [expr [file mtime "[getFilePrefix]/users/guest/metadata"] >\
			[file mtime\
			"[getFilePrefix]/users/guest/metadata-[getVisitorsIP]"]] ) \
			} {
			file copy -force [concat [getFilePrefix]/users/guest/metadata]\
				[concat [getFilePrefix]/users/guest/metadata-[getVisitorsIP]]
		}
		set shouldSortMetadata 1
		return [concat [getFilePrefix]/users/guest/metadata-[getVisitorsIP]]
	} else {
		return [concat [getFilePrefix]/users/$userId/metadata]
	}
}

proc getWideShadowIconFilename {} {
	logProcedureCall "getShadowIconFilename"
	return "[getDocumentURL]/wideshadow.gif"
}

proc getUserName {} {
	global shouldSortMetadata
	logProcedureCall "getUserName"
	switch [getProgramMode] {
		"sidebar" {
			return "sidebar"
		}
		"MagicNotebook" -
		"view" -
		default {
			if {[CGIValue login] != ""} {
				if {[isAdministrator [CGIValue login]]} {
					if {[CGIValue effectiveUserId] != ""} {
						return [CGIValue effectiveUserId]
					}
					if {"[CGIValue switchUserId]" != ""} {
						set shouldSortMetadata 1
						if {"[CGIValue administrativeAction]" == "switchUser"} {
							if {[userExists [CGIValue switchUserId]]} {
								return [CGIValue switchUserId]
							}
						}
					}
				}
				return [CGIValue login]
			} elseif {[CGIValue newLogin] != ""} {
				return [CGIValue newLogin]
			} else {
				switch [CGIValue accessMethod] {
					"wiki" {
						return [CGIValue accessMethod]
					}
					"guest" -
					default {
						return "guest"
					}
				}
			}
		}
	}
}

proc getWithParent {parentID} {
	global metadata
	logProcedureCall "getWithParent"
	set matches {}
	for {set index 0} {$index < [llength $metadata]} {incr index} {
		array set current [lindex $metadata $index]
		if {$current(parent) == $parentID} {
			logProcedureCall "eswp $current(identifier)"
			lappend matches $current(identifier)
		}
	}
	return $matches
}

proc grantAdministrativePriveleges {userId} {
	global administrativeActionResult
	logProcedureCall "grantAdministrativePriveleges"
	if {[setUserFlag "$userId" "administrator"]} {
		set administrativeActionResult "<p><strong>User $userId\
			has been granted administrative priveleges.</strong></p>\n"
	} else {
		set administrativeActionResult "<p><strong>There was an error\
			attempting to grant administrative priveleges to\
			$userId.</strong></p>\n"
	}
}

proc guardAgainstInvalidLogin {} {
	logProcedureCall "guardAgainstInvalidLogin"
	if {[CGIValue newLogin] != ""} {
		# A new login is being created, so don't check it.
		return
	}
	if {([CGIValue login] != "") && ([CGIValue pageMode] != "createLogin") && \
	  ([CGIValue pageMode] != "forgotPassword")} {
		if {![userExists [CGIValue login]]} {
			readFile [concat [getFilePrefix]/general/header]
			puts "<form method=\"post\" action=\"[getActionURL]\" name=\"[getProgramMode]\">"
			printInvalidLoginText
			pageEnd
			exit 0
		} elseif {[isAdministrator [CGIValue login]] && ![userExists [CGIValue\
		  effectiveUserId]]} {
		}
	}
}

proc hasHiddenAncestor {identifier} {
    global metadata
    logProcedureCall "hasHiddenAncestor"
    set flags ""
    set parent ""
    foreach row $metadata {
        array set current $row
        if {$current(identifier) == $identifier} {
            set flags $current(flags)
            set parent $current(parent)
        }
    }
    if {[testFlag $flags "hide"]} {
        return 1
    } elseif {$identifier == "top" || $identifier == "" || $parent == "top" \
      || $parent == ""} {
        return 0
    } else {
        return [hasHiddenAncestor $parent]
    }
}

proc hide {id} {
	global metadata
	logProcedureCall "hide"
	readMetadata
	for {set index 0} {$index < [llength $metadata]} {incr index} {
		array set current [lindex $metadata $index]
		if {$current(identifier) == $id} {
			set current(flags) [clearFlag "$current(flags)" "show"]
			set current(flags) [setFlag "$current(flags)" "hide"]
		set metadata [lreplace $metadata $index $index [array get current]]
		}
	}
}

proc initialize {} {
	global additionalQueryData
	global administrativeActionResult
	global collapsedObject
	global configOptions
	global contentTypeGiven
	global currentReleaseNumber
	global currentVersionNumber
	global debugMode
	global lastClockClicks
	global lockedFiles
	global metadataRead
	global metadataWritten
	global pageModeHasBeenCalled
	global passwordsRead
	global resultArray
	global shouldExpandAppropriately
	global shouldLogProcedureCalls
	global shouldSortMetadata
	global userNotifiedOfLock
	# One of the following two lines should be uncommented.
	set debugMode 0
	#set debugMode 1
	# logProcedureCalls only has effect if debugMode is true.
	set shouldLogProcedureCalls 0
	#set shouldLogProcedureCalls 1
	logProcedureCall "initialize"
	 debugLog "Starting processing..."
	set administrativeActionResult ""
	set lastClockClicks [clock clicks]
	set metadataRead 0
	set metadataWritten 0
	set collapsedObject ""
	set contentTypeGiven 0
	set currentVersionNumber "1.4"
	set currentReleaseNumber "1"
	set lockedFiles {}
	set pageModeHasBeenCalled 0
	set passwordsRead 0
	set shouldSortMetadata 0
	set shouldExpandAppropriately 1
	set userNotifiedOfLock 0
	set configOptions {\
		"actionURL"\
		"cellpadding"\
		"defaultAccessMethod"\
		"defaultDisplayMethod"\
		"documentURL"\
		"filePrefix"\
		"fullBaseURL"\
		"lockTimeout"\
		"mailerCommand"\
		"serverAdminEmail"\
		"shouldAllowGuestAccess"\
		"shouldAllowHtmlSnippets"\
		"shouldAllowLoginAccess"\
		"shouldAllowLoginCreation"\
		"shouldAllowWikiAccess"\
		"textHeight"\
		"textWidth"\
		}
	set additionalQueryData ""
	set configResult(exists) 1
	expr srand([clock clicks])
	puts "Content-type: text/html"
	puts ""
	set contentTypeGiven 1
	CGIParse
	loadConfigFile [getConfigFilename]
	readPasswords
	guardAgainstInvalidLogin
	checkForLogout
	if {[CGIValue pageMode] == "forgotPassword"} {
		readFile [concat [getFilePrefix]/general/header]
		puts "<form method=\"post\" action=\"[getActionURL]\" name=\"[getProgramMode]\">"
		forgotPassword
		pageEnd
		exit 0
	}
	getLock [getMetadataFilename]
	if {[shouldAuthenticate] && [authenticate]} {
		readMetadata
	}
	if {[CGIValue accessMethod] == "guest"} {
		registerQueryData "accessMethod" "guest"
	}
	if {[CGIValue note] != ""} {
		saveSelectedNote [CGIValue note]
	}
	if {[CGIValue shouldsave] == "yes"} {
		saveSubmittedChanges
	}
	logMessage [CGIQuery]
	if {([CGIValue newLogin] == "") && ((![userExists [getUserName]]) ||\
	  ([shouldAuthenticate] && ![authenticate]))} {
		pageStart 0
		printInvalidPasswordText
		pageEnd
		exit 0
	}
	getPageMode
	if {![testUserFlag [getUserName] "metadata_sorted"]} {
		set shouldSortMetadata 1
		setUserFlag [getUserName] "metadata_sorted"
	}
	if {$shouldSortMetadata} {
		sortMetadata
	}
	if {$metadataRead} {
		writeMetadata
	}
	releaseLock [getMetadataFilename]
}

proc isActive {note} {
	global metadata
	logProcedureCall "isActive"
	set index 0
	set shouldContinue 1
	while {$shouldContinue} {
		array set currentRow [lindex $metadata $index]
		if {$index >= [llength $metadata]} {
			set shouldContinue 0
		} else {
			if {$currentRow(identifier) == $note} {
				switch -regexp -- $currentRow(flags) {
					show {
						return 1
					}
					default {
						return 0
					}
				}
			}
		}
		incr index
	}
	return 0
}

proc isAdministrator {login} {
	global passwords
	logProcedureCall "isAdministrator"
	readPasswords
	set index 0
	set shouldContinue 1
	while {$shouldContinue} {
		array set currentRow [lindex $passwords $index]
		if {$index >= [llength $passwords]} {
			set shouldContinue 0
		} else {
			if {$currentRow(login) == $login} {
				switch -regexp -- $currentRow(flags) {
					administrator {
						return 1
					}
					default {
						return 0
					}
				}
			}
		}
		incr index
	}
	return 0
}

proc isAllowed {option {default 0}} {
	logProcedureCall "isAllowed"
	return [isTrue [getConfigValue $option $default]]
}

proc isAncestor {potentialParent potentialChild} {
	logProcedureCall "isAncestor"
	return [isDescendant $potentialChild $potentialParent]
}

proc isDescendant {potentialChild potentialParent} {
	logProcedureCall "isDescendant"
	set shouldContinue 1
	set currentNode $potentialChild
	while {$shouldContinue} {
		if {$currentNode == $potentialParent} {
			return 1
		}
		if {$currentNode == "top"} {
			return 0
		}
		if {$currentNode == $potentialChild} {
			logProcedureCall "id Node $potentialChild is its own ancestor."
		}
		set currentNode [getParent $currentNode]
	}
	return 0
}

proc isFolder {identifier} {
	logProcedureCall "isFolder"
	return [testMetadataFlag $identifier "folder"]
}

proc isNote {identifier} {
	logProcedureCall "isNote"
	return [expr ![isFolder $identifier]]
}

proc isNoteBeingCollapsed {id} {
	global collapsedObject
	logProcedureCall "isNoteBeingCollapsed"
	if {$collapsedObject == $id} {
		return 1
	} else {
		return 0
	}
}

proc isProperAncestor {potentialParent potentialChild} {
	logProcedureCall "isProperAncestor"
	if {$potentialParent != $potentialChild} {
		return [isAncestor $potentialParent $potentialChild]
	} else {
		return 0
	}
}

proc isProperDescendant {potentialChild potentialParent} {
	logProcedureCall "isProperDescendant"
	return [isProperAncestor $potentialParent $potentialChild]
}

proc isSiblingOfAncestor {potentialSiblingOfAncestor node} {
    logProcedureCall "isSiblingOfAncestor"
    return [isAncestor [getParent $potentialSiblingOfAncestor] $node]
}

proc isTrue {optionValue} {
	logProcedureCall "isTrue"
	switch [string tolower $optionValue] {
		true -
		yes -
		on -
		1 {
			return 1
		}
		default {
			return 0
		}
	}
}

proc isValidLogin {login} {
	global passwords
	logProcedureCall "isValidLogin"
	readPasswords
	set index 0
	set shouldContinue 1
	while {$shouldContinue} {
		array set currentRow [lindex $passwords $index]
		if {$index >= [llength $passwords]} {
			set shouldContinue 0
		} else {
			if {($currentRow(login) == $login)} {
				return 1
			}
		}
		incr index
	}
	return 0
}

proc lineBreaksToHtml {text} {
	logProcedureCall "lineBreaksToHtml"
	set lines [split "\n$text\n" "\n"]
	set result ""
	for {set i 0} {$i < [llength $lines]} {incr i} {
		append result [lindex $lines $i]
		if {$i < [expr [llength $lines] - 1]} {
			if {[regexp -- "^\s*$" "[lindex $lines $i]"]} {
				if {[regexp -- "^\s*$" "[lindex $lines [expr $i + 1]]"]} {
					append result "\n"
				} else {
					append result "\n<p>"
				}
			} else {
				if {[regexp -- "^\s*$" "[lindex $lines [expr $i + 1]]"]} {
					append result "</p>\n"
				} else {
					append result "<br>\n"
				}
			}
		}
	}
	return $result
}

proc listUsers {} {
	global passwords
	logProcedureCall "listUsers"
	set breakNeeded 0
	puts -nonewline "<h2>Users with accounts on this system:</h2>\n<p>"
	foreach current $passwords {
		array set currentRow $current
		if {$breakNeeded} {
			puts -nonewline "<br>\n"
		}
		puts -nonewline "$currentRow(login)"
		set breakNeeded 1
	}
	puts -nonewline "</p>\n\
		<p><input type=\"radio\" name=\"pageMode\"\
		value=\"administrative\" onclick=\"document.[getProgramMode].submit()\"\
		checked> Return to the administrative menu.</p>\n\
		<p><input type=\"image\" name=\"Go!\"\ border=\"0\"
		src=\"[getDocumentURL]/submit.jpg\"></p>\n"
}

proc logMessage {message} {
	puts stderr "[getProgramNameWithCapitalizedArticle] \[[clock format [clock seconds]]\]: $message"
	flush stderr
}

proc logProcedureCall {message} {
	global debugMode
	global shouldLogProcedureCalls
	if {$shouldLogProcedureCalls && $debugMode} {
		logMessage $message
	}
}

# New CGI variables should be listed here.
proc mightBeUsedInFilename {variableName} {
	logProcedureCall "mightBeUsedInFilename"
	switch -regexp -- $variableName {
		"^accountManagement$" -
		"^administrativeAction$" -
		"^changePasswordDuplicate" -
		"^changePasswordOld$" -
		"^changePasswordNew$" -
		"^changeUserPasswordPassword$" -
		"^changeUserPasswordDuplicate$" -
		"^delete_" -
		"^header_" -
		"^newUserPassword$" -
		"^newUserPasswordDuplicate$" -
		"^pageMode$" -
		"^password$" -
		"^passwordDuplicate$" -
		"^prefersToUseHtml$" -
		"^previousPageMode$" -
		"^shouldAddTemplates$" -
		"^shouldsave$" -
		"^title_" -
		"^value_" {
			return 0
		}
		"^accessMethod$" -
		"^action$" -
		"^changeUserPasswordEmail$" -
		"^deleteUserId$" -
		"^effectiveUserId$" -
		"^grantAdministrativePrivelegesUserId$" -
		"^importttemplate_" -
		"^lockUserId$" -
		"^login$" -
		"^newlogin$" -
		"^newUserId$" -
		"^resetUserFromTextOnlyUserId$" -
		"^revokeAdministrativePrivelegesUserId$" -
		"^setUserToTextOnlyUserId$" -
		"^note$" -
		"^unlockUserId$" -
		default {
			return 1
		}
	}
}

proc moveDown {id} {
	global metadata
	logProcedureCall "moveDown"
	for {set i 0} {$i < [expr [getNumberOfNotes] - 1]} {incr i} {
		array set current [lindex $metadata $i]
		if {$current(identifier) == $id} {
			set juggle [lindex $metadata [expr $i + 1]]
			set metadata [lreplace $metadata [expr $i + 1] \
				[expr $i + 1] [lindex $metadata $i]]
			set metadata [lreplace $metadata $i $i $juggle]
			return
		}
	}
}

proc moveUp {id} {
	global metadata
	logProcedureCall "moveUp"
	for {set i 1} {$i < [getNumberOfNotes]} {incr i} {
		array set current [lindex $metadata $i]
		if {$current(identifier) == $id} {
			set juggle [lindex $metadata [expr $i - 1]]
			set metadata [lreplace $metadata [expr $i - 1] \
				[expr $i - 1] [lindex $metadata $i]]
			set metadata [lreplace $metadata $i $i $juggle]
			return
		}
	}
}

proc noteExists {noteId} {
	global metadata
	logProcedureCall "noteExists"
	set index 0
	set shouldContinue 1
	readMetadata
	while {$shouldContinue} {
		if {$index >= [llength $metadata]} {
			set shouldContinue 0
		} else {
			array set currentRow [lindex $metadata $index]
			if {$currentRow(identifier) == $noteId} {
				return 1
			}
		}
		incr index
	}
	return 0
}

proc pageEnd {} {
	logProcedureCall "pageEnd"
	puts "</form>"
	readFile [concat [getFilePrefix]/general/footer]
}

proc pageStart {{preserveLogin 1}} {
	logProcedureCall "pageStart"
	readFile [concat [getFilePrefix]/general/header]
	# For MagicNotebook we submit data via the post method.
	puts "<form method=\"post\" action=\"[getActionURL]\" name=\"[getProgramMode]\">"
	#puts "<form method=\"get\" action=\"[getActionURL]\" name=\"[getProgramMode]\">"
	puts "<input type=\"hidden\" name=\"previousPageMode\"\
		value=\"[getPageMode]\">"
	registerQueryData "previousPageMode" [getPageMode]
	if {[CGIExists administrative]} {
		puts "<input type=\"hidden\" name=\"administrative\" value=\"true\">"
		registerQueryData "administrative" "true"
	}
	if {$preserveLogin} {
		if {[CGIValue login] != "" && [authenticate]} {
			puts "<input type=\"hidden\" name=\"login\" value=\"[CGIValue\
				login]\">"
			registerQueryData "login" [CGIValue login]
		}
		if {([CGIValue changePasswordNew] != "") &&\
			([CGIValue changePasswordNew] == \
			[CGIValue changePasswordDuplicate])} {
			puts "<input type=\"hidden\" name=\"password\"\
				value=\"[CGIValue changePasswordNew]\">"
			registerQueryData "password" [CGIValue changePasswordNew]
		} else {
			if {[CGIValue password] != "" && [authenticate]} {
				puts "<input type=\"hidden\" name=\"password\"\
					value=\"[CGIValue password]\">"
				registerQueryData "password" [CGIValue password]
			}
		}
		if {[CGIValue effectiveUserId] != "" && [authenticate]\
			&& [isAdministrator [CGIValue login]]} {
			puts "<input type=\"hidden\" name=\"effectiveUserId\"\
				value=\"[CGIValue effectiveUserId]\">"
			registerQueryData "effectiveUserId" [CGIValue effectiveUserId]
		}
		if {[CGIValue switchUserId] != "" && [authenticate]\
			&& [isAdministrator [CGIValue login]]} {
			puts "<input type=\"hidden\" name=\"effectiveUserId\"\
				value=\"[CGIValue switchUserId]\">"
			registerQueryData "effectiveUserId" [CGIValue switchUserId]
		}
	}
}

proc panic {} {
	global contentTypeGiven
	global lockedFiles
	logProcedureCall "panic"
	while {[llength $lockedFiles] > 0} {
		releaseLock [lindex $lockedFiles 0]
	}
	if { ! $contentTypeGiven } {
		puts "Content-type: text/html"
		puts ""
	}
	# Commented out as causing an infinite loop.
	#readFile [concat [getFilePrefix]/general/header]
	puts "<html><head><title>Sorry...</title><body bgcolor=\"white\">\
		<h1>Sorry...</h1>"
	puts "<p>An error has occured, and the program making these webpages can't\
		recover from it. Please hit your browser's \"<strong>BACK</strong>\"\
		button and choose another option.</p></body></html>"
	#pageEnd
	exit 1
}

proc printHeader {note} {
	logProcedureCall "printHeader"
	puts "[filterText [removeComments [getHeader $note]]]"
}

proc printInvalidLoginText {} {
	logProcedureCall "printInvalidLoginText"
	puts -nonewline "\
		<p>The login you have supplied is incorrect.\n\
		Would you like to try again?</p>\n\
		<p>E-mail address:<br>\n\
		<input type=\"text\" name=\"login\"\
		size=\"[getTextWidth]\"></p>\n\
		<p>Password:<br>\n\
		<input type=\"password\" name=\"password\"\
		size=\"[getTextWidth]\"></p>\n\
		<p><input type=\"radio\" name=\"pageMode\" value=\"view\"\
		onclick=\"document.[getProgramMode].submit()\" checked> Log in<br>\n"
		if {[shouldAllowLoginCreation]} {
			puts -nonewline "\
				<input type=\"radio\" name=\"pageMode\"\
				value=\"createLogin\"
				onclick=\"document.[getProgramMode].submit()\">\
				Create a new login<br>\n"
		}
	puts -nonewline "\
		<input type=\"radio\" name=\"pageMode\"\
		value=\"forgotPassword\"\
		onclick=\"document.[getProgramMode].submit()\">\
		Help! I forgot my password!</p>\n\
		<p><input type=\"image\" name=\"Go!\"\ border=\"0\"
		src=\"[getDocumentURL]/submit.jpg\"></p>\n"
}

proc printInvalidPasswordText {} {
	logProcedureCall "printInvalidPasswordText"
	puts -nonewline "\
		<p>The password you have supplied is incorrect.\n\
		Would you like to try again?</p>\n\
		<p>E-mail address:<br>\n\
		<input type=\"text\" name=\"login\"\
		size=\"[getTextWidth]\"></p>\n\
		<p>Password:<br>\n\
		<input type=\"password\" name=\"password\"\
		size=\"[getTextWidth]\"></p>\n\
		<p><input type=\"radio\" name=\"pageMode\" value=\"view\"\
		onclick=\"document.[getProgramMode].submit()\" checked> Log in<br>\n"
		if {[shouldAllowLoginCreation]} {
			puts -nonewline "\
				<input type=\"radio\" name=\"pageMode\"\
				value=\"createLogin\"
				onclick=\"document.[getProgramMode].submit()\">\
				Create a new login<br>\n"
		}
	puts -nonewline "\
		<input type=\"radio\" name=\"pageMode\"\
		value=\"forgotPassword\"\
		onclick=\"document.[getProgramMode].submit()\">\
		Help! I forgot my password!</p>\n\
		<p><input type=\"image\" name=\"Go!\"\ border=\"0\"
		src=\"[getDocumentURL]/submit.jpg\"></p>\n"
}

proc printNoteName {note} {
	logProcedureCall "printNoteName"
	puts "<h2>[getNoteName $note]</h2>"
}

proc printSnippet {note} {
	logProcedureCall "printSnippet"
	puts "[filterText [removeComments [selectSnippet $note]]]"
}

proc processAccountManagement {} {
	global accountManagementResult
	logProcedureCall "processAccountManagement"
	switch -exact -- [CGIValue "accountManagement"] {
		"addTemplates" {
			addTemplates
			set accountManagementResult "<p><strong>The template(s) you\
				selected have been added.</strong></p>"
		}
		"changePassword" {
			switch -exact [getProgramMode] {
				sidebar {
					set userName [CGIValue login]
				}
				view -
				default {
					set userName [getUserName]
				}
			}
			if {[authenticateInternal $userName\
				[CGIValue changePasswordOld]]} {
				if {[changePassword $userName [CGIValue changePasswordNew]\
					[CGIValue changePasswordDuplicate]]} {
					set accountManagementResult "<p><strong>You have\
						successfully changed your password.</strong></p>"
				} else {
					set accountManagementResult "<p><strong>An error occurred,\
						so your password is the old value.</strong></p>"
				}
			}
		}
		"modifyConciseness" {
			if {[isTrue [CGIValue conciseDisplay]]} {
				setUserFlag [getUserName] "concise"
				set accountManagementResult "<p><strong>The Magic Notebook\
				  will now close down things you aren't using.</strong></p>"
			} else {
				clearUserFlag [getUserName] "concise"
				set accountManagementResult "<p><strong>If you open something,\
				  the Magic Notebook will now leave it open until you close
				  it.</strong></p>"
			}
		}
		"modifyEditSnippetStatus" {
			if {[isTrue [CGIValue editSnippets]]} {
				setUserFlag [getUserName] "editsnippets"
				set accountManagementResult "<p><strong>You can now add random\
				  text to notes.</strong></p>"
			} else {
				clearUserFlag [getUserName] "editsnippets"
				set accountManagementResult "<p><strong>When you edit a\
				  note, you won't be bothered with controls to add random\
				  text.</strong></p>"
			}
		}
		"modifyHideMenuFromViewPageStatus" {
			# Logic is reversed here so that upgrades will continue to show
			# the same behaviour until the user modifies it.
			if { [isTrue [CGIValue hideMenuFromViewPage]]} {
				if {[testUserFlag [getUserName] "editlink"]} {
					set postscript ""
				} else {
					set postscript "<p><strong><em>Clicking on the title of a\
						note or folder will let you edit it. This is needed\
						so that you will have a way to access other\
						pages.</em></strong></p>"
				}
				setUserFlag [getUserName] "hide_menu_from_view_page"
				setUserFlag [getUserName] "editlink"
				set accountManagementResult "<p><strong>The main viewing page\
					will now be displayed without the navigation\
					menu&mdash;the menu will only be on the other\
					pages.</strong></p>$postscript"
			} else {
				clearUserFlag [getUserName] "hide_menu_from_view_page"
				set accountManagementResult "<p><strong>There will now be a\
					navigation menu at the bottom of the main viewing\
					page.</strong></p>"
			}
		}
		"modifyLinkStatus" {
			if {[isTrue [CGIValue editLinks]]} {
				setUserFlag [getUserName] "editlink"
				set accountManagementResult "<p><strong>Clicking on the name of
				  a note will now edit it.</strong></p>"
			} else {
				clearUserFlag [getUserName] "editlink"
				set accountManagementResult "<p><strong>Clicking on the\
					name of a note will now open or close\
					it.</strong></p>"
				if {[testUserFlag [getUserName] "hide_menu_from_view_page"]} {
					clearUserFlag [getUserName] "hide_menu_from_view_page"
					set accountManagementResult "$accountManagementResult\
						<p><strong>In order that you will be able to access\
						the navigation menu, the front page has the navigation\
						menu now.</strong></p>"
				} else {
				}
			}
		}
		"modifySeeAllSnippetsStatus" {
			if {[isTrue [CGIValue seeAllSnippets]]} {
				setUserFlag [getUserName] "see_all_snippets"
				set accountManagementResult "<p><strong>You will now see all\
					bits of random text in a given note. (Note that some\
					notes will not have random text.)</strong></p>"
			} else {
				clearUserFlag [getUserName] "see_all_snippets"
				set accountManagementResult "<p><strong>You will now see only\
					one piece of random text in a given note if it has random\
					text. (Note that some notes will not have random\
					text.)</strong></p>"
			}
		}
		"updateHTMLPreference" {
			if {[CGIValue prefersToUseHtml] != ""} {
				setUserFlag [getUserName] "html"
			} else {
				clearUserFlag [getUserName] "html"
			}
		}
	}
	writePasswords
}

proc processAdministrativeAction {} {
	global administrativeActionResult
	logProcedureCall "processAdministrativeAction"
	if {[isAdministrator [CGIValue "login"]]} {
		switch -exact -- [CGIValue "administrativeAction"] {
			"addUser" {
				set newUserId [CGIValue "newUserId"]
				set newUserPassword [CGIValue "newUserPassword"]
				set newUserPasswordDuplicate [CGIValue\
					"newUserPasswordDuplicate"]
				if {[addUser "$newUserId" "$newUserPassword"\
					"$newUserPasswordDuplicate"]} {
					set administrativeActionResult "<p><strong>New user\
						[CGIValue newUserId] successfully
						created.</strong></p>\n"
				} else {
					set administrativeActionResult "<p><strong>An error\
						occurred in attempting to add user [CGIValue\
						newUserId].</strong></p>\n"
				}
			}
			"changeUserPassword" {
				if {[changePassword [CGIValue changeUserPasswordEmail]\
					[CGIValue changeUserPasswordPassword]\
					[CGIValue changeUserPasswordDuplicate]]} {
					set administrativeActionResult "<p><strong>Password\
						successfully changed for [CGIValue\
						changeUserPasswordEmail].</strong></p>\n"
				} else {
					set administrativeActionResult "<p><strong>Error: password\
						not successfully changed.</strong></p>\n"
				}
			}
			"deleteUser" {
				deleteUser [CGIValue deleteUserId]
			}
			"grantAdministrativePriveleges" {
				grantAdministrativePriveleges [CGIValue\
					grantAdministrativePrivelegesUserId]
			}
			"revokeAdministrativePriveleges" {
				revokeAdministrativePriveleges [CGIValue\
					revokeAdministrativePrivelegesUserId]
			}
			"lockUser" {
				if {[setUserFlag [CGIValue lockUserId] "locked"]} {
					set administrativeActionResult "<p><strong>User
						<em>[CGIValue lockUserId]</em> is now\
						locked.</strong></p>\n"
				} else {
					set administrativeActionResult "<p><strong>An error\
						occurred in attempting to lock user <em>[CGIValue\
						lockUserId]</em>.<strong></p>\n"
				}
			}
			"unlockUser" {
				if {[clearUserFlag [CGIValue unlockUserId] "locked"]} {
					set administrativeActionResult "<p><strong>User\
						<em>[CGIValue unlockUserId]</em> is now\
						unlocked.</strong></p>\n"
				} else {
					set administrativeActionResult "<p><strong>An error\
						occurred in attempting to unlock user <em>[CGIValue\
						unlockUserId]</em>.<strong></p>\n"
				}
			}
			"setUserToTextOnly" {
				if {[setUserFlag [CGIValue setUserToTextOnlyUserId] "text"]} {
					set administrativeActionResult "<p><strong>User\
						<em>[CGIValue setUserToTextOnlyUserId]</em> is now set\
						to text-only viewing.<strong></p>\n"
				} else {
					set administrativeActionResult "<p><strong>An error\
						occurred in attempting to set user <em>[CGIValue\
						setUserToTextOnlyUserId]</em> to text-only\
						viewing.</strong></p>\n"
				}
			}
			"resetUserFromTextOnly" {
				if {[clearUserFlag [CGIValue resetUserFromTextOnlyUserId]\
					"text"]} {
					set administrativeActionResult "<p><strong>User\
						<em>[CGIValue resetUserFromTextOnlyUserId]</em> is no\
						longer set to text-only viewing.</strong></p>\n"
				} else {
					set administrativeActionResult "<p></strong>An error\
						occurred in attempting to set user <em>[CGIValue\
						resetUserFromTextOnlyUserId]</em> to no longer have\
						text-only viewing.</strong></p>\n"
				}
			}
		}
	} else {
		logMessage "Non-administrative user somehow got into\
			processAdministrativeAction."
	}
}

proc quoteHtmlMetacharacters {toQuote} {
	logProcedureCall "quoteHtmlMetacharacters"
	regsub -all "&" "$toQuote" "\\&amp;" toQuote
	regsub -all "<" "$toQuote" "\\&lt;" toQuote
	regsub -all ">" "$toQuote" "\\&gt;" toQuote
	return $toQuote
}

proc readFile {filename} {
	logProcedureCall "readFile"
	if { [catch {open $filename r} fileId] } {
		logMessage "Couldn't open file $filename. Exiting from readFile...\
		$fileId"
		panic
	} else {
		puts [read $fileId]
		close $fileId
	}
}

proc readMetadata {{shouldForce 0}} {
	global metadata
	global metadataRead
	logProcedureCall "readMetadata"
	if {($metadataRead && !$shouldForce) || !([userExists [getUserName]])} {
		return
	}
	set metadata [readUserMetadata [getUserName] $shouldForce]
	set metadataRead 1
}

proc readUserMetadata {userId {shouldForce 0}} {
	logProcedureCall "readUserMetadata"
	set metadata {}
	if { [catch {open [getUserMetadataFilename $userId] r} fileId] } {
		if { [catch {open [getUserMetadataFilename $userId] w} fileId] } {
			close $fileId
			return {}
		}
	} else {
		set shouldContinue 1
		if {[eof $fileId]} {
			set shouldContinue 0
		}
		while {$shouldContinue} {
			set currentRow(identifier) [readNextField $fileId]
			if {[eof $fileId]} {
				set shouldContinue 0
			}
			set currentRow(title) [readNextField $fileId]
			if {[eof $fileId]} {
				set shouldContinue 0
			}
			set currentRow(header) [readNextField $fileId]
			if {[eof $fileId]} {
				set shouldContinue 0
			}
			set currentRow(flags) [readNextField $fileId]
			if {[eof $fileId]} {
				set shouldContinue 0
			}
			set currentRow(parent) [readNextField $fileId]
			if {$shouldContinue} {
				lappend metadata [array get currentRow]
			}
			gets $fileId
			if { [eof $fileId] } {
				set shouldContinue 0
			}
		}
		close $fileId
	}
	return $metadata
}

proc readNextField {fileId} {
	logProcedureCall "readNextField"
	set padding ""
	set padding " "
	while {$padding != "\"" && $padding != ""} {
		set padding [read $fileId 1]
	}
	return [readString $fileId]
}

proc readNote {filename} {
	logProcedureCall "readNote"
	global notes
	if {[getProgramMode] == "MagicNotebook" && [testMetadataFlag $filename\
	  "folder"]} {
		# We don't display this way.
		return {}
	}
	set result {}
	set fullFilename "[getFilePrefix]/users/[getUserName]/$filename"
	if { [catch {open $fullFilename r} fileId] } {
		# The note has just been deleted or is otherwise available.
		return {}
	} else {
		set shouldContinue 1
		while {$shouldContinue} {
			set currentField [readNextField $fileId]
			if {[string length $currentField] > 0} {
				lappend result $currentField
			}
			gets $fileId
			if { [eof $fileId] } {
				set shouldContinue 0
			}
		}
		close $fileId
	}
	return $result
}

proc readPasswords {{shouldForce 0}} {
	global passwords
	global passwordsRead
	logProcedureCall "readPasswords [getPasswordFilename]"
	if {$passwordsRead && !$shouldForce} {
		return
	}
	if { [catch {open [getPasswordFilename] r} fileId] } {
		logMessage "Couldn't open [getPasswordFilename] for reading.  Exiting..."
		panic
	} else {
		set shouldContinue 1
		if {[eof $fileId]} {
			set shouldContinue 0
		}
		while {$shouldContinue} {
			set currentRow(login) [readNextField $fileId]
			if {[eof $fileId]} {
				set shouldContinue 0
			}
			set currentRow(password) [readNextField $fileId]
			if {[eof $fileId]} {
				set shouldContinue 0
			}
			set currentRow(flags) [readNextField $fileId]
			if {[eof $fileId]} {
				set shouldContinue 0
			}
			set currentRow(parent) [readNextField $fileId]
			if {$shouldContinue} {
				lappend passwords [array get currentRow]
			}
			gets $fileId
			if { [eof $fileId] } {
				set shouldContinue 0
			}
		}
		close $fileId
		set passwordsRead 1
	}
}

# When a file with pickled strings has been opened, and the opening quotation
# mark for a string has been encountered, read from the stream until the
# closing quotation mark has been encountered.  '\' escapes the next character;
# this behavior is simplified from usual escape quotation.
proc readString {fileId} {
	set shouldContinue 1
	set result ""
	logProcedureCall "readString"
	while {$shouldContinue} {
		set currentCharacter [read $fileId 1]
		switch -exact -- $currentCharacter {
			"" {
				set shouldContinue 0
			}
			"\"" {
				set shouldContinue 0
			}
			"\\" {
				set result "$result[read $fileId 1]"
			}
			default {
				set result "$result$currentCharacter"
			}
		}
	}
	return $result
}

proc registerQueryData {field value} {
	global additionalQueryData
	logProcedureCall "registerQueryData"
	regsub -all "@" "$field" "%40" field
	regsub -all "@" "$value" "%40" value
	if {$additionalQueryData == ""} {
		set additionalQueryData "$field=$value"
	} else {
		set additionalQueryData "$additionalQueryData&$field=$value"
	}
}

proc registerLock {filename} {
	global lockedFiles
	logProcedureCall "registerLock"
	if {[lsearch -exact $lockedFiles $filename] == -1} {
		lappend lockedFiles $filename
	}
}

proc releaseLock {filename} {
	logProcedureCall "releaseLock"
	deregisterLock $filename
	file delete "$filename.lock"
}

proc removeComments {stringWithComments} {
	logProcedureCall "removeComments"
	set result ""
	set lines [split $stringWithComments "\n"]
	foreach currentLine $lines {
		if {[regexp "^#" $currentLine]} {
			#It's a comment--doesn't need to be displayed.
		} else {
			if {$result != ""} {
				set result "$result\n$currentLine"
			} else {
				set result "$currentLine"
			}
		}
	}
	return $result
}

# Hasn't fully been debugged.  Could be overprotective. Or underprotectuve
proc removeShellMetacharacters {untrusted} {
	logProcedureCall "removeShellMetacharacters"
	set result "$untrusted"
	regsub -all \[\!\\\$\^\\\&\\\*\(\)\~\\\[\\\]\\\\\|\{\}\`\"\'\;\<\>\?\#\]\
		$result "" result
	return $result
}

proc retrievePassword {} {
	logProcedureCall "retrievePassword"
	set login [CGIValue login]
	if { [isValidLogin $login ] } {
		set password [getPassword $login]
		if { [catch {open "| [getMailerCommand $login]" r+} pipeId] } {
			puts -nonewline "<p>We're sorry, but we weren't able to mail you\
				your password.  Please contact the <a\
				href=\"mailto:[getServerAdminEmail]\">administrator</a> and\
				inform him of the problem.</p>\n"
		} else {
			puts -nonewline $pipeId "From:\
				[getProgramNameWithCapitalizedArticle]\
				<[getServerAdminEmail]>\
				\nTo: $login\
				\nSubject: Your [getProgramName] password\
				\n\nDear [getProgramName] Visitor;\
				\n\nYour [getProgramName] password at [getFullBaseURL]\
				\nis \"$password\".  (Your login is the e-mail address you\
				used, \n\"$login\".)  We look forward to having you back.\
				\n\
				\nIf you were not expecting a password reminder, please\
				disregard this message.\n\
				\n\
				\n\
				\nSincerely (for a computer program),\
				\n[getProgramNameWithCapitalizedArticle]\n"
			close $pipeId
			puts -nonewline "<p>Your password has been e-mailed to you and\
				should arrive shortly.  When it does, you should be able\
				to log in:</p>\n"
			displayLogin
		}
	} else {
		puts -nonewline "<p>We're sorry, but we were unable to look up your\	
			account name.  You might have made a minor typo, or have an\
			account with a different server that looks like this one.  Would\
			you like to try to log in again?</p>\n"
		displayLogin
		pageEnd
		exit 0
	}
}

proc revokeAdministrativePriveleges {userId} {
	global administrativeActionResult
	logProcedureCall "revokeAdministratorPriveleges"
	if {[clearUserFlag "$userId" "administrator"]} {
		set administrativeActionResult "<p><strong>User $userId\
			has been had administrative priveleges revoked.</strong></p>\n"
	} else {
		set administrativeActionResult "<p><strong>There was an error\
			attempting to revoke administrative priveleges for\
			$userId.</strong></p>\n"
	}
}

proc sanitizePotentialFilenameElement {untrusted} {
	logProcedureCall "sanitizePotentialFilenameElement"
	set result $untrusted
	regsub -all "/" $result "" result
	regsub -all "\n" $result "" result
	return $result
}

proc saveSelectedNote {identifier} {
	global metadata
	logProcedureCall "saveSelectedNote"
	readMetadata
	set index 0
	set shouldContinue 1
	while {$shouldContinue} {
		array set currentRow [lindex $metadata $index]
		if {$index >= [llength $metadata]} {
			set shouldContinue 0
		} else {
			if {$currentRow(identifier) == $identifier} {
				set currentRow(flags) [setFlag "$currentRow(flags)"\
					"selected"]
				set metadata [lreplace $metadata $index $index [array\
					get currentRow]]
			} else {
				set currentRow(flags) [clearFlag "$currentRow(flags)"\
					"selected"]
				set metadata [lreplace $metadata $index $index [array\
					get currentRow]]
			}
		}
		incr index
	}
	expandAppropriately $identifier
}

proc saveSubmittedChanges {} {
	global metadata
	global shouldExpandAppropriately
	global shouldSortMetadata
	logProcedureCall "saveSubmittedChanges"
	readMetadata
	set previous [CGIValue previousPageMode]
	set note [CGIValue note]
	getLock "[getFilePrefix]/users/[getUserName]/$note"
	set noteContents [readNote $note]
	set shouldSortMetadata 0
	foreach key [CGIKeys] {
		switch -regexp $key {
			{^title_(.*)$} {
				regexp {^(.*?)_(.*)$} $key match prefix id
				set index 0
				set shouldContinue 1
				while {$shouldContinue} {
					if {$index >= [llength $metadata]} {
						set shouldContinue 0
					} else {
						array set current [lindex $metadata $index]
						if {$current(identifier) == $id} {
							set current(title) [CGIValue $key]
							set metadata [lreplace $metadata $index\
								$index [array get current]]
							set shouldSortMetadata 1
						}
					}
					incr index
				}
			}
			{^header_(.*)$} {
				regexp {^(.*?)_(.*)$} $key match prefix id
				set index 0
				set shouldContinue 1
				while {$shouldContinue} {
					if {$index >= [llength $metadata]} {
						set shouldContinue 0
					} else {
						array set current [lindex $metadata $index]
						if {$current(identifier) == $id} {
							set current(header) [CGIValue $key]
							set metadata [lreplace $metadata $index\
								$index [array get current]]
						}
					}
					incr index
				}
			}
			{^value_(.*)_(.*?)$} {
				regexp {^(.*?)_(.*)_(.*?)$} $key match prefix id position
				if { [CGIValue $key] != ""} {
					if {$position < [llength $noteContents]} {
						set noteContents [lreplace $noteContents $position\
							$position [CGIValue $key]]
					} else {
						lappend noteContents [CGIValue $key]
					}
				} else {
					if {$position < [llength $noteContents]} {
						set noteContents [lreplace $noteContents $position\
							$position [getDeletionMarker]]
					}
				}
			}
			{^delete_(.*)$} {
				regexp {^(.*?)_(.*)_(.*?)$} $key match prefix id sequence
				set noteContents [lreplace $noteContents $position\
					$position [getDeletionMarker]]
			}
		}
	}
	for {set index 0} {$index < [llength $noteContents]} {} {
		if { [lindex $noteContents $index] == [getDeletionMarker]} {
			set noteContents [lreplace $noteContents $index $index]
		} else {
			incr index
		}
	}
	writeNote $note $noteContents
	releaseLock "[getFilePrefix]/users/[getUserName]/$note"
}

proc selectNote {identifier} {
	global metadata
	logProcedureCall "selectNote"
	readMetadata
	set index 0
	set shouldContinue 1
	while {$shouldContinue} {
		array set currentRow [lindex $metadata $index]
		if {$index >= [llength $metadata]} {
			set shouldContinue 0
		} else {
			if {$currentRow(identifier) == $identifier} {
				set currentRow(flags) [setFlag "$currentRow(flags)"\
					"selected"]
			} else {
				set currentRow(flags) [clearFlag "$currentRow(flags)"\
				    "selected"]
			}
			set metadata [lreplace $metadata $index $index [array\
				get currentRow]]
		}
		incr index
	}
}

proc selectSnippet {note} {
	logProcedureCall "selectSnippet"
	set noteContents [readNote $note]
	if {[testUserFlag [getUserName] "see_all_snippets"]} {
		set result "\n"
		foreach {currentSnippet} $noteContents {
			set result "$result$currentSnippet\n\n"
		}
		return $result
	} else {
		set noteIndex [expr int( rand() * [llength $noteContents] ) ]
		return [lindex $noteContents $noteIndex]
	}
}

proc setFlag {target flag} {
	logProcedureCall "setFlag"
	if {[regexp -- "$flag" "$target"]} {
	} else {
		set target "$target $flag"
		regsub -all {\s+} $target { } target
	}
	return $target
}

proc setUserFlag {userId flag} {
	global passwords
	logProcedureCall "setUserFlag"
	getLock [getPasswordFilename]
	readPasswords
	if {[userExists $userId]} {
		set index 0
		set shouldContinue 1
		while {$shouldContinue} {
			array set currentRow [lindex $passwords $index]
			if {$index >= [llength $passwords]} {
				set shouldContinue 0
			} else {
				if {$currentRow(login) == $userId} {
					set currentRow(flags) [setFlag "$currentRow(flags)"\
						"$flag"]
					set passwords [lreplace $passwords $index $index [array\
						get currentRow]]
					writePasswords
					releaseLock [getPasswordFilename]
					return 1
				}
			}
			incr index
		}
	}
	releaseLock [getPasswordFilename]
	return 0
}

proc shouldAllowGuestAccess {} {
	logProcedureCall "shouldAllowGuestAccess"
	return [isAllowed "shouldAllowGuestAccess"]
}

proc shouldAllowHtmlSnippets {} {
	logProcedureCall "shouldAllowHtmlSnippets"
	return [isAllowed "shouldAllowHtmlSnippets" 1]
}

proc shouldAllowLoginAccess {} {
	logProcedureCall "shouldAllowLoginAccess"
	return [isAllowed "shouldAllowLoginAccess"]
}

proc shouldAllowLoginCreation {} {
	logProcedureCall "shouldAllowLoginCreation"
	return [isAllowed "shouldAllowLoginCreation"]
}

proc shouldAllowSidebarAccess {} {
	logProcedureCall "shouldAllowSidebarAccess"
	return [isAllowed "shouldAllowSidebarAccess" 1]
}

proc shouldAllowWikiAccess {} {
	logProcedureCall "shouldAllowWikiAccess"
	return [isAllowed "shouldAllowWikiAccess"]
}

proc shouldAuthenticate {} {
	logProcedureCall "shouldAuthenticate"
	switch -- [CGIValue previousPageMode] {
		createLogin {
			if {[CGIValue login] == "" && [CGIValue password] == ""} {
				return 0
			}
		}
	}
	if {![userExists [getUserName]]} {
		return 1
	}
	switch -- [getPageMode] {
		connect -
		createLogin -
		entryMenu -
		retrievePassword {
			return 0
		}
		default {
			switch -- [CGIValue accessMethod] {
				guest -
				wiki {
					return 0
				}
				default {
					return 1
				}
			}
		}
	}
}

proc shouldExpandOnlySelected {} {
	logProcedureCall "shouldExpandOnlySelected"
	return [testUserFlag [getUserName] "concise"]
}

proc show {id} {
	logProcedureCall "show"
	global metadata
	for {set index 0} {$index < [llength $metadata]} {incr index} {
		array set current [lindex $metadata $index]
		if {$current(identifier) == $id} {
			set current(flags) [clearFlag "$current(flags)" "hide"]
			set current(flags) [setFlag "$current(flags)" "show"]
			set metadata [lreplace $metadata $index $index [array get current]]
		}
	}
}

proc showMagicNotebook {} {
	logProcedureCall "showMagicNotebook"
	if {[getProgramMode] == "metaSnippets"} {
		editDisplayForParent "top"
	} else {
		displayForParent "top"
	}
}

proc showSnippets {} {
	logProcedureCall "showSnippets"
	foreach {note} [getNotes] {
		if {[isActive $note]} {
			if {[getProgramMode] != "sidebar"} {
				printNoteName $note
			}
			printHeader $note
			printSnippet $note
		}
	}
}

proc showTemplates {} {
	logProcedureCall "showTemplates"
	if {[userExists template]} {
		set templateMetadata [readUserMetadata template]
		puts -nonewline "<strong>"
		if {[llength $templateMetadata] > 0} {
			set shouldAddBreak 0
			foreach current $templateMetadata {
				array set currentRow $current
				if {![noteExists $currentRow(identifier)]} {
					if {$shouldAddBreak} {
						puts -nonewline "<br>\n"
					}
					puts -nonewline "<input type=\"checkbox\"\
						name=\"importtemplate_$currentRow(identifier)\">\
						$currentRow(title)"
					set shouldAddBreak 1
				}
			}
		}
		puts -nonewline "</strong>"
	}
}

proc sortMetadata {} {
	global metadata
	debugLog "sortMetadata"
	if {![info exists metadata]} {
		readMetadata
	}
	if {[file exists [getMetadataFilename]]} {
		set metadata [sortMetadataInner $metadata]
	}
}

proc sortMetadataInner {toSort {criterionToSortOn "itemName"}} {
	debugLog "sortMetadataInner"
	# Randomized QuickSort implemented after bubble sort took too long.
	# We append the internal name to the external key so the output
	# will always be in the same order, i.e. two fields with the same
	# name won't appear in variable order.
	if {[llength $toSort] < 2} {
		return $toSort
	}
	array set dividingKeyRow [lindex $toSort [expr int( rand() * [llength \
	  $toSort] ) ] ]
	set dividingKey $dividingKeyRow(identifier)
	set lesserBin {}
	set greaterOrEqualBin {}
	switch $criterionToSortOn {
		fullPathname {
			set dividingFieldToCompare [string tolower [getFullPath $dividingKey]]
		}
		itemName -
		default {
			set dividingFieldToCompare [string tolower [getNoteName $dividingKey]]
		}
	}
	foreach current $toSort {
		array set currentKeyRow $current
		set currentKey $currentKeyRow(identifier)
		switch $criterionToSortOn {
			fullPathname {
				set currentFieldToCompare [string tolower [getFullPath $currentKey]]
			}
			itemName -
			default {
				set currentFieldToCompare [string tolower [getNoteName $currentKey]]
			}
		}
		# Sort on displayed field value, using the key as a tiebreaker
		# so as to have consistent behavior between two items of the same
		# key.
		if {[string compare -nocase $currentFieldToCompare \
		  $dividingFieldToCompare] < 0} {
			lappend lesserBin $current
		} elseif {[string compare -nocase $currentFieldToCompare \
		  $dividingFieldToCompare] > 0} {
			lappend greaterOrEqualBin $current
		} else {
			if {[string compare -nocase $currentKey $dividingKey] < 0} {
				lappend lesserBin $current
			} else {
				lappend greaterOrEqualBin $current
			}
		}
	}
	return [concat [sortMetadataInner $lesserBin $criterionToSortOn]\
		[sortMetadataInner $greaterOrEqualBin $criterionToSortOn]]
}

proc testFlag {target flags} {
	logProcedureCall "testFlag"
	if {[regexp -- "$flags" "$target"]} {
		return 1
	} else {
		return 0
	}
}

proc testMetadataFlag {identifier flagName} {
	global metadata
	logProcedureCall "testMetadataFlag"
	foreach currentPacked $metadata {
		array set currentUnpacked $currentPacked
		if {$currentUnpacked(identifier) == $identifier} {
			return [testFlag $currentUnpacked(flags) $flagName]
		}
	}
	return 0
}

proc testUserFlag {userId flag} {
	global passwords
	logProcedureCall "testUserFlag"
	readPasswords
	if {[userExists $userId]} {
		set index 0
		set shouldContinue 1
		while {$shouldContinue} {
			array set currentRow [lindex $passwords $index]
			if {$index >= [llength $passwords]} {
				set shouldContinue 0
			} else {
				if {$currentRow(login) == $userId} {
					if {[regexp -- "$flag" "$currentRow(flags)"]} {
						return 1
					} else {
						return 0
					}
				}
			}
			incr index
		}
	}
	return 0
}

proc textToHtml {text} {
	logProcedureCall "textToHtml"
	return [lineBreaksToHtml [quoteHtmlMetacharacters $text]]
}

proc timeMarker {{text ""}} {
	global lastClockClicks
	logProcedureCall "timeMarker"
	# The number of clock clicks per second depends on the computer and should
	# be calibrated to get meaningful output.
	set currentClockClicks [clock clicks]
	if {$text != ""} {
		logMessage "********** clicks elapsed [expr $currentClockClicks -\
			$lastClockClicks]; message $text"
	} else {
		logMessage "********** clicks elapsed [expr $currentClockClicks -\
			$lastClockClicks]"
	}
	set lastClockClicks $currentClockClicks
}

# Will only take effect in debug mode.
proc turnOffProcedureCallLogging {} {
	global shouldLogProcedureCalls
	set shouldLogProcedureCalls 0
	debugLog "Procedure call logging is now turned off."
}

# Will only take effect in debug mode.
proc turnOnProcedureCallLogging {} {
	global shouldLogProcedureCalls
	set shouldLogProcedureCalls 1
	debugLog "Procedure call logging is now turned on."
}

proc updateDisplayedData {} {
	global metadata
	global collapsedObject
	global expandedObject
	global shouldExpandAppropriately
	logProcedureCall "updateDisplayedData"
	readMetadata
	set action [CGIValue action]
	set notebookMove [CGIValue notebookMove]
	if {$notebookMove == ""} {
		set notebookMove [CGIValue motion]
	}
	switch -regexp $notebookMove {
		{^(.*?)_(.*?)_(.*)$} {
			regexp {^(.*?)_(.*?)_(.*)$} $notebookMove match moveLikeCommand item \
			  destination
			switch -exact -- $moveLikeCommand {
				motion -
				notebookMove {
					for {set index 0} {$index < [llength $metadata]} \
					  {incr index} {
						array set current [lindex $metadata $index]
						if {$current(identifier) == $item} {
							set current(parent) $destination
							set metadata [lreplace $metadata $index $index\
							  [array get current]]
						}
					}
				}
				default {
				}
			}
		}
	}
	switch -regexp $action {
		{^(.*?)_(.*)$} {
			regexp {^(.*?)_(.*)$} $action match updateCommand actionObject
			switch -exact -- $updateCommand {
				collapse {
					collapse $actionObject
					set collapsedObject $actionObject
				}
				deletefolder {
					set shouldExpandAppropriately 0
					deleteFolder $actionObject
				}
				deletenote {
					set shouldExpandAppropriately 0
					deleteNote $actionObject
				}
				expand {
					expand $actionObject
					set expandedObject $actionObject
				}
			}
		}
	}
}

proc userExists {login} {
	global passwords
	logProcedureCall "userExists"
	switch -- $login {
		guest -
		wiki {
			return 1
		}
		default {
			set index 0
			set shouldContinue 1
			while {$shouldContinue} {
				if {$index >= [llength $passwords]} {
					set shouldContinue 0
				} else {
					array set currentRow [lindex $passwords $index]
					if {$currentRow(login) == $login} {
						return 1
					}
				}
				incr index
			}
			return 0
		}
	}
}

proc welcomeScreen {login password} {
	logProcedureCall "welcomeScreen"
	puts -nonewline "<input type=\"hidden\" name=\"login\" value=\"$login\">\n\
		<input type=\"hidden\" name=\"password\" value=\"$password\">\n"
	registerQueryData "login" $login
	registerQueryData "password" $password"
	readFile [concat [getFilePrefix]/general/welcome]
	if {[getProgramMode] != "MagicNotebook"} {
		if {[userExists "template"]} {
			puts -nonewline "<p>You may, if you are interested, include\
				existing view collections in your account&mdash;you are free\
				to adjust them, if you do so.  Please check what you are\
				interested in:</p>\n<p>"
			showTemplates
			puts -nonewline "</p>"
		}
	}
	puts -nonewline "<p><input type=\"hidden\" name=\"pageMode\"\
		value=\"view\">\n\
		<input type=\"hidden\" name=\"shouldAddTemplates\" value=\"yes\">\n\
		<input type=\"image\" name=\"Continue\"\ border=\"0\"
		src=\"[getDocumentURL]/submit.jpg\"></p>\n"
	registerQueryData "pageMode" "view"
	registerQueryData "shouldAddTemplates" "yes"
}

proc writeMetadata {{shouldForce 0}} {
	global metadata
	global metadataRead
	global metadataWritten
	logProcedureCall "writeMetadata"
	if {$metadataRead && ($shouldForce || !$metadataWritten)} {
		set metadataWritten 1
		if { [catch {open "[getMetadataFilename].new-[getVisitorsIP]" w} fileId] } {
			logMessage "Couldn't open file [getMetadataFilename]. Exiting from writeMetadata... $fileId"
			panic
		} else {
			set index 0
			set shouldContinue 1
			while {$shouldContinue} {
				array set currentRow [lindex $metadata $index]
				if {$index >= [llength $metadata]} {
					set shouldContinue 0
				} else {
					writeString $fileId $currentRow(identifier)
					puts -nonewline $fileId " "
					writeString $fileId $currentRow(title)
					puts -nonewline $fileId " "
					writeString $fileId $currentRow(header)
					puts -nonewline $fileId " "
					writeString $fileId $currentRow(flags)
					puts -nonewline $fileId " "
					writeString $fileId $currentRow(parent)
					puts $fileId ""
				}
				incr index
			}
			close $fileId
			file rename -force "[getMetadataFilename].new-[getVisitorsIP]" [getMetadataFilename]
		}
	}
}

proc writeNote {noteID noteContents} {
	logProcedureCall "writeNote"
	if { [set error [catch {open "[getSnippetFilename\
		$noteID].new-[getVisitorsIP]" w} fileId]] } {
		logMessage "Couldn't open file [getSnippetFilename $noteID].new-[getVisitorsIP] for writing.  Exiting from writeNote... $error $fileId"
		panic
	} else {
		set index 0
		set shouldContinue 1
		while {$shouldContinue} {
			if {$index >= [llength $noteContents]} {
				set shouldContinue 0
			} else {
				set current [lindex $noteContents $index]
				writeString $fileId $current
				puts $fileId ""
			}
			incr index
		}
	 	close $fileId
		file rename -force "[getSnippetFilename $noteID].new-[getVisitorsIP]" [getSnippetFilename $noteID]
	}
}

proc writePasswords {} {
	global passwords
	logProcedureCall "writePasswords"
	if { [catch {open "[getPasswordFilename].new-[getVisitorsIP]" w} fileId] } {
		logMessage "Couldn't open file [getPasswordFilename]. Exiting from writePasswords... $fileId"
		panic
	} else {
		set index 0
		set shouldContinue 1
		while {$shouldContinue} {
			array set currentRow [lindex $passwords $index]
			if {$index >= [llength $passwords]} {
				set shouldContinue 0
			} else {
				writeString $fileId $currentRow(login)
				puts -nonewline $fileId " "
				writeString $fileId $currentRow(password)
				puts -nonewline $fileId " "
				writeString $fileId $currentRow(flags)
				puts -nonewline $fileId " "
				writeString $fileId $currentRow(parent)
				puts $fileId ""
			}
			incr index
		}
		close $fileId
		file rename -force "[getPasswordFilename].new-[getVisitorsIP]" [getPasswordFilename]
	}
}

# Write a string, delineated by '"' and with '\' as the quote character.
proc writeString {fileId toRecord} {
	logProcedureCall "writeString $fileId $toRecord"
	puts -nonewline $fileId "\""
	for {set i 0} {$i < [string length $toRecord]} {incr i} {
		switch -exact -- [string range $toRecord $i $i] {
			"\"" -
			"\\" {
				puts -nonewline $fileId "\\"
				puts -nonewline $fileId [string range $toRecord $i $i]
			}
			default {
				puts -nonewline $fileId [string range $toRecord $i $i]
			}
		}
	}
	puts -nonewline $fileId "\""
}

#
# Script body
#

initialize
pageStart

switch -exact [getPageMode] {
	"accountManagement" {
		if {[authenticate]} {
			puts -nonewline "<input type=\"hidden\" name=\"pageMode\"\
				value=\"accountManagement\">\n\
				<h2>Account Management</h2>\n\
				<p><strong><em>To change one of these settings, click the\
				button to the left of that setting, then make the change just\
				below, and click \"Go!\"</em></strong></p>\
				<p><strong>For example, to keep notes and folders\
				open, click \"Do you want [getProgramNameWithArticle] to clean\
				up notes you're not using?\", and then \"Keep notes and\
				folders open until I close them.\", and then\
				\"Go!\"</strong></p>\n\
				<p><strong>On this form, radio buttons (used for selection) do\
				not submit by themselves.  You will need to press the submit\
				button at the bottom of the screen.</strong></p>\n"
			registerQueryData "pageMode" "accountManagement"
			if {[info exists accountManagementResult]} {
				puts -nonewline "<font\
					size=\"+1\">$accountManagementResult</font>"
			}
			puts -nonewline ""
			puts -nonewline "<hr>\n"
			puts -nonewline "<p><br><input type=\"radio\"\
				name=\"accountManagement\" value=\"changePassword\">\
				Change my password.<\p>\n\
				<blockquote>\n\
				<p>Old password:<br>\n\
				<input type=\"password\" name=\"changePasswordOld\"\
				size=\"[expr [getTextWidth] - 10]\"><br>\n\
				New password:<br>\n\
				<input type=\"password\" name=\"changePasswordNew\"\
				size=\"[expr [getTextWidth] - 10]\"><br>\n\
				Repeat new password:<br>\n\
				<input type=\"password\" name=\"changePasswordDuplicate\"\
				size=\"[expr [getTextWidth] - 10]\"></p>\n"
			puts -nonewline "</blockquote><hr>\n"
			puts -nonewline "\
				<p><input type=\"radio\" name=\"accountManagement\"
				value=\"modifyConciseness\"> Do you want\
				[getProgramNameWithArticle] to clean up notes you're not\
				using?</p>\
				<blockquote>"
			if {[testUserFlag [getUserName] "concise"]} {
				puts -nonewline "\
					<p><input type=\"radio\" checked\
					name=\"conciseDisplay\" value=\"yes\"> Close\
					folders and notes I am not using.<br>\
					<input type=\"radio\" name=\"conciseDisplay\"\
					value=\"no\"> Keep notes and folders open\
					until I close them.</p>"
			} else {
				puts -nonewline "\
					<p><input type=\"radio\"\
					name=\"conciseDisplay\" value=\"yes\"> Close\
					folders and notes I am not using.<br>\
					<input type=\"radio\" checked name=\"conciseDisplay\"\
					value=\"no\"> Keep notes and folders open\
					until I close them.</p>"
			}
			puts -nonewline "</blockquote><hr>\n"
			if {[getProgramMode] == "MagicNotebook"} {
				puts -nonewline "\
					<p><input type=\"radio\" name=\"accountManagement\"\
					value=\"modifyLinkStatus\"> When you are viewing\
					information, what do you want to happen when you click\
					on the name of a note or folder?</p>\n\
					<blockquote>"
				if {[testUserFlag [getUserName] "editlink"]} {
					puts -nonewline "\
						<p><input type=\"radio\" checked\
						name=\"editLinks\" value=\"yes\"> When I click
						on a note/folder name, I want to edit it.<br>\
						<input type=\"radio\" name=\"editLinks\"\
						value=\"no\"> When I click on a note/folder
						name, I want to open or close it. <em>If you choose
						this, the menu will always be displayed from the front
						page so that you can get to other pages.</em></p>"
				} else {
					puts -nonewline "\
						<p><input type=\"radio\"\
						name=\"editLinks\" value=\"yes\"> When I click
						on a note/folder name, I want to edit it.<br>\
						<input type=\"radio\" checked name=\"editLinks\"\
						value=\"no\"> When I click on a note/folder name, I\
						want to open or close it.</p>"
				}
			}
			puts -nonewline "</blockquote><hr>\n"
			puts -nonewline "\
				<p><input type=\"radio\" name=\"accountManagement\"\
				value=\"modifyEditSnippetStatus\"> When you edit a note, do\
				you want be able to add random text to notes that don't have\
				it? <em>This will make the note-editing page more\
				complicated.</em></p>\n\
				<blockquote>"
			if {[testUserFlag [getUserName] "editsnippets"]} {
				puts -nonewline "\
					<p><input type=\"radio\" checked\
					name=\"editSnippets\" value=\"yes\"> I want to be\
					able to make random text appear at the bottom of the\
					note.<br>\
					<input type=\"radio\" name=\"editSnippets\"\
					value=\"no\"> I would rather have the editing pages be\
					simpler.</p>"
			} else {
				puts -nonewline "\
					<p><input type=\"radio\"\
					name=\"editSnippets\" value=\"yes\"> I want to be\
					able to make random text appear at the bottom of the\
					note.<br>\
					<input type=\"radio\" name=\"editSnippets\" checked\
					value=\"no\"> I would rather have the editing pages be\
					simpler.</p>"
			}
			puts -nonewline "</blockquote><hr>\n"
			puts -nonewline "\
				<p><input type=\"radio\" name=\"accountManagement\"\
				value=\"modifySeeAllSnippetsStatus\"> Would you like all\
				available random text to be displayed, instead of one randomly\
				chosen piece?</p>\n\
				<blockquote>"
			if {[testUserFlag [getUserName] "see_all_snippets"]} {
				puts -nonewline "\
					<p><input type=\"radio\" name=\"seeAllSnippets\"
					value=\"yes\" checked> I want to see all of the random text
					that is available for the selected note.<br>\
					<input type=\"radio\" name=\"seeAllSnippets\"\
					value=\"no\"> If there is random text, I want to see one\
					part at a time. <em>This is the normal way to use\
					[getProgramNameWithArticle].</em></p>"
			} else {
				puts -nonewline "\
					<p><input type=\"radio\" name=\"seeAllSnippets\"
					value=\"yes\"> I want to see all of the random text
					that is available for the selected note.<br>\
					<input type=\"radio\" name=\"seeAllSnippets\"\
					value=\"no\" checked> If there is random text, I want to\
					see one part at a time. <em>This is the normal way to use\
					[getProgramNameWithArticle].</em></p>"
			}
			puts -nonewline "</blockquote><hr>\n"
			puts -nonewline "<p><input type=\"radio\"\
				name=\"accountManagement\"\
				value=\"modifyHideMenuFromViewPageStatus\"> Would you like to\
				hide the menu at the bottom of the main viewing page? (The\
				menus on other pages will still be available.)</p>\
				<blockquote>"
			if {[testUserFlag [getUserName] "hide_menu_from_view_page"]} {
				puts -nonewline "\
					<p><input type=\"radio\" name=\"hideMenuFromViewPage\"\
					value=\"yes\" checked> Hide the standard navigation menu\
					from the\
					main viewing page. Only folders and notes will be\
					shown when you are looking at the main page. <em>If you
					choose this, links will be edit links so you still have a
					way to access other pages.</em><br>\
					<input type=\"radio\" name=\"hideMenuFromViewPage\"\
					value=\"no\"> Show the standard navigation menu from the\
					viewing page. <em>If you're not sure what option to\
					select, this one would probably be best.</em></p>"
			} else {
				puts -nonewline "\
					<p><input type=\"radio\" name=\"hideMenuFromViewPage\"\
					value=\"yes\"> Hide the standard navigation menu from the\
					main viewing page. Only folders and notes will be\
					shown, although the menu will be visible from other\
					pages.<br>\
					<input type=\"radio\" name=\"hideMenuFromViewPage\"\
					value=\"no\" checked> Show the standard navigation menu\
					from the\
					viewing page. If you're not sure what option to select,\
					this one would probably be best.</p>"
			}
			puts -nonewline "</blockquote><hr>\n"
			puts -nonewline "\
				<p><input type=\"radio\" name=\"accountManagement\"\
				value=\"returnToSnippets\" checked>\
				Return to reading [getProgramNameWithArticle].<br><br><br>\n\
				<input type=\"image\" name=\"Go!\"\ border=\"0\"
				src=\"[getDocumentURL]/submit.jpg\"></p>\n"
		}
	}
	"administrative" {
		if {[isAdministrator [getUserName]]} {
			puts -nonewline "<input type=\"hidden\" name=\"pageMode\"\
				value=\"administrativeAction\">\n\
				<h2>Administrative Utilities for\
				[getProgramNameWithArticle], version\
				[getCurrentVersionNumber], release\
				[getCurrentReleaseNumber].</h2>\n\
				<p><strong><em>To use one of these options, click the button\
				to the left of that setting, then make the change just below,\
				and click \"Go!\"</em></strong></p>\
				<p><strong>For example, to switch to a new user,\
				click \"Switch to a different user...\", then type the user's\
				e-mail address, and then\ \"Go!\"</strong></p>\n\
				<p><strong>On this form, radio buttons (used for selection) do\
				not submit by themselves.  You will need to press the submit\
				button at the bottom of the screen.</strong></p>\n"
			registerQueryData "pageMode" "administrativeAction"
			if {[info exists administrativeActionResult]} {
				puts -nonewline "<font\
					size=\"+1\">$administrativeActionResult</font>"
			}
			puts -nonewline "<p>These options complement the controls\
				available from the configuration file.</p>\n\
				<hr>\
				<p><input type=\"radio\" name=\"administrativeAction\"\
				value=\"addUser\"> Add a new user to the system.</p>\n\
				<blockquote>\n
				<p>E-mail address:<br>\n
				<input type=\"text\" name=\"newUserId\"\
				size=\"[expr [getTextWidth] - 10]\"><br>\n
				Password:<br>\n\
				<input type=\"password\" name=\"newUserPassword\"\
				size=\"[expr [getTextWidth] - 10]\"><br>
				Repeat password:<br>\n\
				<input type=\"password\" name=\"newUserPasswordDuplicate\"\
				size=\"[expr [getTextWidth] - 10]\"></p>\n\
				</blockquote>\
				<hr>\
				<p><input type=\"radio\" name=\"administrativeAction\"\
				value=\"switchUser\"> Switch to a different user (switch to\
				user \"guest\" to edit what a guest sees, or \"template\" to\
				edit the template data given to new users).</p>\n\
				<blockquote>\
				<p>E-mail address:<br>\n\
				<input type=\"text\" name=\"switchUserId\"\
				size=\"[expr [getTextWidth] - 10]\"></p>\n\
				</blockquote>\
				<hr>\
				<p><input type=\"radio\" name=\"administrativeAction\"\
				value=\"changeUserPassword\"> Change a user's password.</p>\n\
				<blockquote>\
				User's e-mail address:<br>\n\
				<input type=\"text\" name=\"changeUserPasswordEmail\"\
				size=\"[expr [getTextWidth] - 10]\"><br>\n\
				New password:<br>\n\
				<input type=\"password\" name=\"changeUserPasswordPassword\"\
				size=\"[expr [getTextWidth] - 10]\"><br>\n\
				Repeat new password:<br>\n\
				<input type=\"password\" name=\"changeUserPasswordDuplicate\"\
				size=\"[expr [getTextWidth] - 10]\"></p>\n\
				</blockquote>\
				<hr>\
				<p><input type=\"radio\" name=\"administrativeAction\"\
				value=\"setUserToTextOnly\"> Set user to text-only access (no
				working HTML displayed in [getProgramNameWithArticle]).</p>\n\
				<blockquote>\
				E-mail address:<br>\n\
				<input type=\"text\" name=\"setUserToTextOnlyUserId\"\
				size=\"[expr [getTextWidth] - 10]\"></p>\n\
				</blockquote>\
				<hr>\
				<p><input type=\"radio\" name=\"administrativeAction\"\
				value=\"resetUserFromTextOnly\"> Remove a text-only access
				restriction from a given user.</p>\n\
				<blockquote>\
				E-mail address:<br>\n\
				<input type=\"text\" name=\"resetUserFromTextOnlyUserId\"\
				size=\"[expr [getTextWidth] - 10]\"></p>\n\
				</blockquote>\
				<hr>\
				<p><input type=\"radio\" name=\"administrativeAction\"\
				value=\"lockUser\"> Lock user account</p>\n\
				<blockquote>\
				E-mail address:<br>\n\
				<input type=\"text\"\ name=\"lockUserId\"\
				size=\"[expr [getTextWidth] - 10]\"></p>\n\
				</blockquote>\
				<hr>\
				<p><input type=\"radio\" name=\"administrativeAction\"\
				value=\"unlockUser\"> Unlock user account</p>\n\
				<blockquote>\
				E-mail address:<br>\n\
				<input type=\"text\"\ name=\"unlockUserId\"\
				size=\"[expr [getTextWidth] - 10]\"></p>\n\
				</blockquote>\
				<hr>\n\
				<p><input type=\"radio\" name=\"administrativeAction\"\
				value=\"grantAdministrativePriveleges\"> Grant administrative\
				priveleges<br>\n\
				<blockquote>\
				E-mail address:<br>\n\
				<input type=\"text\"\
				name=\"grantAdministrativePrivelegesUserId\"\
				size=\"[expr [getTextWidth] - 10]\"></p>\n\
				</blockquote></p>\
				<hr>\
				<p><input type=\"radio\" name=\"administrativeAction\"\
				value=\"revokeAdministrativePriveleges\"> Revoke administrative\
				priveleges</p>\n\
				<blockquote>\
				E-mail address:<br>\n\
				<input type=\"text\"\
				name=\"revokeAdministrativePrivelegesUserId\"\
				size=\"[expr [getTextWidth] - 10]\"></p>\n\
				</blockquote>\
				<hr>\
				<p><input type=\"radio\" name=\"administrativeAction\"\
				value=\"deleteUser\"> DELETE an existing user.</p>\n\
				<blockquote>\
				E-mail address:<br>\n\
				<input type=\"text\" name=\"deleteUserId\"\
				size=\"[expr [getTextWidth] - 10]\"></p>\n\
				</blockquote>\
				<hr>\
				<p><input type=\"radio\" name=\"administrativeAction\"\
				value=\"listUsers\"> List users</p>\n\
				<hr>\
				<p><input type=\"radio\" name=\"administrativeAction\"\
				value=\"returnToSnippets\" checked> Return to\
				[getProgramNameWithArticle].<font size=\"-4\"><br><br></font></p>\
				<p><input type=\"image\" name=\"Go!\"\ border=\"0\"
				src=\"[getDocumentURL]/submit.jpg\"></p>\n"
		} else {
			puts -nonewline "<p>We're sorry, but this option requires\
				administrative priveleges, and your account does not presently\
				have them.</p>\n\
				<input type=\"hidden\" name=\"pageMode\"\
				value=\"view\">\n\
				<p><input type=\"image\" name=\"Return to\
				[getProgramNameWithArticle]\"\
				border=\"0\"\
				src=\"[getDocumentURL]/return_to_view.jpg\"></p>\n"
			registerQueryData "pageMode" "view"
		}
	}
	"connect" {
		puts -nonewline "<input type=\"hidden\" name=\"accessMethod\"\
			value=\"[CGIValue accessMethod]\">\n"
		registerQueryData "accessMethod" [CGIValue accessMethod]
		switch -exact [CGIValue accessMethod] {
			"guest" {
				if {[shouldAllowGuestAccess]} {
					if {[getProgramMode] == "MagicNotebook"} {
						readMetadata
						displayForParent "top"
					} else {
						showSnippets
					}
					puts -nonewline "<input type=\"hidden\" name=\"pageMode\"\
						value=\"connect\">\n"
					registerQueryData "pageMode" "connect"
					if {[getProgramMode] == "MagicNotebook"} {
						displayStandardChoices view 1
					} else {
						puts -nonewline "<p><input type=\"image\"\ border=\"0\"
							name=\"Show another page\"
							src=\"[getDocumentURL]/show_another_page.jpg\"></p>"
					}
				} else {
					accessError
				}
			}
			"wiki" {
				if {[shouldAllowWikiAccess]} {
					puts -nonewline "<input type=\"hidden\" name=\"login\"\
						value=\"wiki\">\n"
					registerQueryData "login" "wiki"
					if {[getProgramMode] == "MagicNotebook"} {
						readMetadata
						displayForParent "top"
					} else {
						showSnippets
					}
					displayStandardChoices view 1
				} else {
					accessError
				}
			}
			"login" {
				if {[shouldAllowLoginAccess]} {
					displayLogin
				} else {
					accessError
				}
			}
			"createLogin" {
				if {[shouldAllowLoginCreation]} {
					displayCreateLogin
				} else {
					accessError
				}
			}
			"forgotPassword" {
				if {[shouldAllowLoginAccess]} {
					forgotPassword
				} else {
					accessError
				}
			}
		}
		if {[getProgramMode] == "sidebar"} {
			if {[shouldAllowLoginAccess]} {
				displayLogin
			} else {
				accessError
			}
		}
	}
	"createLogin" {
		createLogin
	}
	"entryMenu" {
		puts -nonewline "<input type=\"hidden\" name=\"pageMode\"\
			value=\"connect\">\n"
		registerQueryData "pageMode" "connect"
		puts -nonewline "<h2>Welcome</h2>\n\
			<p>Choose from the following ways of using\
			[getProgramNameWithArticle]:</p>"
		set isAccessAvailable 0
		if {[shouldAllowGuestAccess]} {
			puts -nonewline "<input type=\"radio\" name=\"accessMethod\"\
				value=\"guest\"\
				onclick=\"document.[getProgramMode].submit()\""
			if {[getDefaultAccessMethod] == "guest"} {
				puts -nonewline " checked"
			}
			puts -nonewline "> Guest<br>\n"
			set isAccessAvailable 1
		}
		if {[shouldAllowWikiAccess]} {
			puts -nonewline "<input type=\"radio\" name=\"accessMethod\"\
				value=\"wiki\"\
				onclick=\"document.[getProgramMode].submit()\""
			if {[getDefaultAccessMethod] == "wiki"} {
				puts -nonewline " checked"
			}
			puts -nonewline "> Wiki-like<br>\n"
			set isAccessAvailable 1
		}
		if {[shouldAllowLoginAccess]} {
			puts -nonewline "
				<input type=\"radio\" name=\"accessMethod\" value=\"login\"\
				onclick=\"document.[getProgramMode].submit()\""
			if {[getDefaultAccessMethod] == "login"} {
				puts -nonewline " checked"
			}
			puts -nonewline "> Log in as registered user<br>\n"
			if {[shouldAllowLoginCreation]} {
				puts -nonewline "<input type=\"radio\" name=\"accessMethod\"\
					value=\"createLogin\"\
					onclick=\"document.[getProgramMode].submit()\">\
					Create new account so you can access [getProgramMode].<br>\n"
			}
			puts -nonewline "<input type=\"radio\" name=\"accessMethod\"\
				value=\"forgotPassword\"\
				onclick=\"document.[getProgramMode].submit()\">\
				Help! I forgot my password.<br>\n"
			set isAccessAvailable 1
		}
		if {$isAccessAvailable} {
			puts -nonewline "<p><input type=\"image\" name=\"Go!\"\
				border=\"0\"
				src=\"[getDocumentURL]/submit.jpg\"></p>\n"
		} else {
			puts -nonewline "<p>Hmm...  The people in charge of this [getProgramName]\
				page have set it up, but haven't given any way for people to\
				use it.  You might want to e-mail them and let them know it\
				won't let anyone in.</p>\n"
		}
	}
	"listUsers" {
		if {[isAdministrator [getUserName]]} {
			listUsers
		}
	}
	"forgotPassword" {
		forgotPassword
	}
	"view" {
		if {![shouldAuthenticate] || [authenticate]} {
			if {[getProgramMode] == "MagicNotebook"} {
				showMagicNotebook
			} else {
				showSnippets
			}
			if { ! [testUserFlag [getUserName] "hide_menu_from_view_page"]} {
				displayStandardChoices view 1
			}
		}
	}
	"metaSnippets" {
		if {[authenticate]} {
			switch -exact $editCommand {
				moveup {
					moveUp $actionObject
				}
				movedown {
					moveDown $actionObject
				}
				hide {
					hide $actionObject
				}
				show {
					show $actionObject
				}
				"" {
				}
			}
			puts "<input type=\"hidden\" name=\"pageMode\" \
				value=\"metaSnippetsAction\">"
			registerQueryData "pageMode" "metaSnippetsAction"
			if {[getProgramMode] == "MagicNotebook"} {
				showMagicNotebook
			} else {
				puts "<p>Select an action:</p>"
				set noteNumber 0
				foreach {note} [getNotes] {
					printNoteName $note
					puts -nonewline "<p>"
					puts "<input type=\"radio\" name=\"action\"\
						value=\"editnote_$note\"\
						onclick=\"document.[getProgramMode].submit()\"\
						>\
						Edit note &nbsp; "
					if {[isActive $note]} {
						puts "<input type=\"radio\" name=\"action\"\
							value=\"hide_$note\"\
							onclick=\"document.[getProgramMode].submit()\"\
							>\
							Hide &nbsp; "
					} else {
						puts "<input type=\"radio\" name=\"action\"\
							value=\"show_$note\"\
							onclick=\"document.[getProgramMode].submit()\"\
							>\
							Show &nbsp; "
					}
					if {$noteNumber > 0} {
						puts "<input type=\"radio\" name=\"action\"\
							value=\"moveup_$note\"\
							onclick=\"document.[getProgramMode].submit()\"\
							>\
							Move up &nbsp; "
					}
					if {$noteNumber < [expr [getNumberOfNotes] - 1]} {
						puts "<input type=\"radio\" name=\"action\"\
							value=\"movedown_$note\"\
							onclick=\"document.[getProgramMode].submit()\"\
							>\
							Move down &nbsp; "
					}
					puts -nonewline "</p>\n"
					incr noteNumber
				}
			}
			puts "<hr>"
			puts "<p>"
			if {[getProgramMode] == "MagicNotebook"} {
				displayNewNoteMenu
				displayNewFolderMenu
			} else {
				puts "<input type=\"radio\" name=\"action\" value=\"newNote\"\
					onclick=\"document.[getProgramMode].submit()\"\
					>\n\
					Create a new note.<br>\n"
			}
			displayStandardChoices metaSnippets 0
			}
		}
	"editFolder" {
		if {[authenticate]} {
			switch -exact $editCommand {
				hide {
					hide $actionObject
				}
				show {
					show $actionObject
				}
			}
			editFolder $actionObject
		}
	}
	"editNote" {
		if {[authenticate]} {
			editNote $actionObject
		}
	}
	"newFolder" {
		if {[authenticate]} {
			editFolder [createFolder]
		}
	}
	"newSubFolder" {
		if {[authenticate]} {
			if {[CGIValue newfolder] != "newfolder_noop" && [CGIValue\
			  newfolder] != ""} {
				regexp {^(.*?)_(.*)$} [CGIValue newfolder] match editCommand \
					actionObject
				editFolder [createFolder $actionObject]
			} else {
				editFolder [createFolder [getSelectedEntity]]
			}
		}
	}
	"newSubNote" {
		if {[authenticate]} {
			if {[CGIValue newnote] != "newnote_noop" && [CGIValue\
			  newnote] != ""} {
				regexp {^(.*?)_(.*)$} [CGIValue newnote] match editCommand \
					actionObject
				editNote [createNote $actionObject]
			} else {
				editNote [createNote [getSelectedEntity]]
			}
		}
	}
	"newNote" {
		if {[authenticate]} {
			editNote [createNote]
		}
	}
	"retrievePassword" {
		retrievePassword
	}
    "search" {
        displaySearchResults
        displayStandardChoices search 1
    }
	"sidebar" {
		if {[shouldAllowSidebarAccess]} {
			showSnippets
		} else {
			accessError
		}
	}
}

pageEnd
